{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#welcome-to-pokie","title":"Welcome to Pokie","text":"<p>Pokie is an REST web framework built on top of Flask, Rick and Rick-db libraries, following three-layer and clean architecture design principles.</p> <p>It features an object-oriented design, borrowing from common patterns found in other languages, such as dependency injection, service location, factories and object composition. It also offers the following functionality:</p> <ul> <li>Modular design;</li> <li>Dependency registry;</li> <li>CLI command support;</li> <li>Jobs (objects invoked periodically to perform a task);</li> <li>Fixtures;</li> <li>Unit testing support with pytest;</li> <li>Code generation;</li> <li>Automatic endpoint generation;</li> <li>REST-oriented service design;</li> <li>Compatibility with Flask;</li> <li>Forward-only SQL migrations;</li> <li>PostgreSQL support;</li> </ul> <p>Note: Pokie is still under heavy development and should not be considered stable or production-ready.</p>"},{"location":"#tl-dr-tutorial","title":"TL; DR; tutorial","text":"<ol> <li>Create the application entrypoint, called main.py:</li> </ol> <pre><code>from rick.resource.config import EnvironmentConfig\nfrom pokie.config.template import BaseConfigTemplate, PgConfigTemplate, TestConfigTemplate\nfrom pokie.core import FlaskApplication\nfrom pokie.core.factories.pgsql import PgSqlFactory\n\nclass Config(EnvironmentConfig, BaseConfigTemplate, PgConfigTemplate, TestConfigTemplate):\n    # @todo: add your config options or overrides here\n    pass\n\ndef build_pokie():\n    # load configuration from ENV\n    cfg = Config().build()\n\n    # modules to load &amp; initialize\n    modules = [\n        #@ todo: add your modules here\n\n    ]\n\n    # factories to run\n    factories = [\n        PgSqlFactory, \n        # @todo: add additional factories here\n    ]\n\n    # build app\n    pokie_app = FlaskApplication(cfg)\n    flask_app = pokie_app.build(modules, factories)\n    return pokie_app, flask_app\n\n\nmain, app = build_pokie()\n\nif __name__ == '__main__':\n    main.cli()\n</code></pre> <ol> <li>Use our application to scaffold a module:</li> </ol> <pre><code>$ python3 main.py codegen:module my_module_name .\n</code></pre> <ol> <li>Add your newly created module to the module list on main.py:</li> </ol> <pre><code>    (...)\n    # modules to load &amp; initialize\n    modules = [\n        'my_module_name',  # our newly created module\n\n    ]\n    (...)\n</code></pre> <ol> <li>Implement the desired logic in the module</li> </ol>"},{"location":"fixtures/","title":"Fixtures","text":"<pre><code>from rick.base import Di\nfrom rick.mixin import Injectable, Runnable\n\nclass CustomFixture(Injectable, Runnable):\n\n    def run(self, di:Di):\n        # do things here\n        pass\n</code></pre>"},{"location":"signals/","title":"Adding signal handlers","text":"<pre><code>import signal\n\n\ndef signal_handler(di, signalnum, stack_trace):\n    pass\n\n# get signal manager\nmgr = di.get(DI_SIGNAL) # type: pokie.core.SignalManager\n\n# register custom handler\nmgr.add_handler(signal.SIGINT, signal_handler())\n</code></pre>"},{"location":"codegen/codegen/","title":"Code Generation","text":"<p>Pokie provides several code generation mechanisms, that can produce either source code or runtime classes.</p>"},{"location":"codegen/codegen/#generating-request-records","title":"Generating Request Records","text":""},{"location":"codegen/codegen/#generating-dto-records","title":"Generating DTO Records","text":""},{"location":"http/camelcase_json_response/","title":"CamelCaseJsonResponse class","text":"<p>The CamelCaseJsonResponse modifies JsonResponse behaviour by attempting to camelCase JSON fields on the response. This provides an effective mechanism to generate camelCase structures from snake_case sources, such as FieldMapper objects or other commonly used Python structures.</p> <p>Example: <pre><code>    # our response data\n    data = {\n        \"first_name\": \"John\",\n        \"last_name\": \"Connor\",\n    }\n\n    # build response object\n    response = CamelCaseJsonResponse(data)\n\n    # output: '{\"success\":true,\"data\":{\"firstName\":\"John\", \"lastName\":\"Connor\"}'\n    print(response.get_data(True))\n</code></pre></p>"},{"location":"http/dbgridrequest/","title":"DbGridRequest class","text":"<p>The DbGridRequest class offers a convenient way of parsing and validating DbGrid parameters from a REST endpoint. It is the underlying mechanism used by RestView listing functionality.</p> <p>This class extracts and validates a set of parameters from a dictionary - usually from a GET request - against the list of fields of the desired record type. Additionally, it may also provide camelCase conversion functionality and sane defaults on listing operations.</p> <p>Please note that DbGridRequest does not perform actual field type validation - eg. performing exact matching on a numeric field with an arbitrary string will likely result in an exception.</p>"},{"location":"http/dbgridrequest/#supported-parameters","title":"Supported parameters","text":"Name Type Example Description offset int offset=1 optional OFFSET clause to apply to the SQL query limit int limit=10 optional LIMIT clause to apply to the SQL query sort string sort=\"name:asc,age\" optional list of field names and ordering for the ORDER by clause match string match=\"field:value|field:value\" optional list of fields and values to perform exact matching search string search=\"john\" optional free text search string"},{"location":"http/dbgridrequest/#offset-limit","title":"offset, limit","text":"<p>Numeric positive values to define the window for the results.</p>"},{"location":"http/dbgridrequest/#sort","title":"sort","text":"<p>An optional list of field names to order by. Multiple field names can be separated by a comma. An optional ordering direction can be specified by suffixing the field name with \":\" and then the desired order (either asc or desc). If no order is specified, a default ordering sequence is used.</p>"},{"location":"http/dbgridrequest/#match","title":"match","text":"<p>A list of fieldnames and values to perform exact match. The fieldnames and values are concatenated with ':', and multiple fieldname:value pairs can be concatenated with '|'.</p> <p>Please note, no validation is perfomed on the value data type. Invalid data types used to perform exact matching may result in exceptions when executing the SQL, so make sure any execution is wrapped with a try... Except handler.</p>"},{"location":"http/dbgridrequest/#search","title":"search","text":"<p>Free text search, to be performed on the specified specified search fields (defined when calling dbgrid_parameters()). If no search fields are specified, this value will produce no effect.</p>"},{"location":"http/dbgridrequest/#class-methods","title":"Class Methods","text":""},{"location":"http/dbgridrequest/#dbgridrequestrecord-typerecord-translator-translator-none-use_camel_casefalse","title":"DBGridRequest(record: Type[Record], translator: Translator = None, use_camel_case=False)","text":"<p>Instantiates a DBGridRequest using the FieldMapper record, with an optional translator object. If use_camel_case is True, camelCase field names are automatically converted to snake_case on both match and sorting operations - eg. the field \" phone_number\" can now also be referenced as \"phoneNumber\".</p>"},{"location":"http/dbgridrequest/#dbgridrequestdbgrid_parameterslist_limit-int-0-search_fields-list-none-dict","title":"DBGridRequest.dbgrid_parameters(list_limit: int = 0, search_fields: list = None) -&gt; dict","text":"<p>This method returns a named dictionary with all the arguments required by RestServiceMixin.list(). It can optionally receive a default limit value to be applied to the query, and a list of field names to perform free text search.</p>"},{"location":"http/dbgridrequest/#usage","title":"Usage","text":"<p>The typical usage scenario is as a regular RequestObject within a specific view method:</p> <pre><code>from pokie.constants import DEFAULT_LIST_SIZE\nfrom pokie.http import PokieView\nfrom pokie.rest import DbGridRequest\nfrom flask import request\n\n\nclass MyView(PokieView):\n\n    def get(self):\n        # MyDbRecord is the DTO record to be used\n        req = DbGridRequest(MyDbRecord)\n\n        # attempt to validate optional DbGrid GET parameters\n        if not req.is_valid(request.args):\n            return self.request_error(req)\n\n        try:\n            # self.svc is a RestServiceMixin object\n\n            count, data = self.svc.list(\n                **dbgrid_request.dbgrid_parameters(\n                    DEFAULT_LIST_SIZE,  # apply default LIMIT clause\n                    [MyDbRecord.name, ]  # limit free text search to the \"name\" field\n                )\n            )\n\n            # assemble result\n            result = {\n                \"total\": count,\n                \"items\": data\n            }\n            # return data\n            return self.success(result)\n\n        except Exception as e:\n            # exception may happen because of mismatched data type, such as matching strings to int fields\n            self.logger.exception(e)\n            return self.error()\n</code></pre>"},{"location":"http/error_handler/","title":"Error Handling","text":""},{"location":"http/error_handler/#flask-errors","title":"Flask errors","text":"<p>Pokie provides a pluggable class-based mechanism to override the default Flask error handlers and provide appropriate JSON responses following the global JsonResponse format. These classes must extend Injectable. Please refer to the default class  pokie.http.HttpErrorHandler for implementation details.</p> <p>The error handler class to be used is defined by a configuration setting in BaseConfigTemplate - CFG_HTTP_ERROR_HANLDER. The value of this setting is the canonical path name of the class to be used; By default, pokie.http.HttpErrorHandler.</p> <p>The created object is also registered in the global registry, and can be accessed with the constant DI_HTTP_ERROR_HANDLER.</p>"},{"location":"http/error_handler/#httperrorhandler-class","title":"HttpErrorHandler class","text":"<p>This class provides JSON-formatted responses for Flask errors for the following HTTP codes:</p> Code Message 400 400 Bad Request: The browser (or proxy) sent a request that this server could not understand. 404 404 Not Found: The requested URL was not found on the server. 405 405 Method Not Allowed: The method is not allowed for the requested URL. 500 500 Internal Server Error"},{"location":"http/extending_views/","title":"Extending Views","text":"<p>PokieView functionality can be extended in several ways, either by using pre-dispatch hooks, subclassing or by using Mixins.</p>"},{"location":"http/extending_views/#using-hooks","title":"Using Hooks","text":"<p>Hooks are methods that are called before performing the dispatch of a given request, and they are maintained in two list attributes - PokieView.dispatch_hooks and PokieView.internal_hooks. Because when a request is received these methods are called in order sequence by name, by using two lists we guarantee that expensive system hooks - such as automatic body  serialization - are postponed to execute after all application hooks, such as authentication.</p> <p>All hooks must use the interface (method:str, *args: t.Any, **kwargs: t.Any) -&gt; Optional[ResponseReturnValue] and if they return a value different than None, the dispatch is immediately aborted and that value is used as a Response.</p> <p>There is no specific naming nomenclature for hooks, but due to their status as protected functions, their name should start with underscore (\"_\").</p>"},{"location":"http/extending_views/#hooks-in-subclasses","title":"Hooks in subclasses","text":"<p>Adding custom hooks to subclasses is quite simple - just override the init() method, add your hooks, and fill the appropriate lists with their names:</p> <pre><code>from pokie.constants import DI_CONFIG\nfrom pokie.http import PokieView\nfrom flask import request\nfrom typing import Any, Optional\nfrom flask.typing import ResponseReturnValue\n\nclass TokenAuthView(PokieView):\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # get hardcoded auth key from a config value\n        self.auth_token = self.di.get(DI_CONFIG).GET(\"auth_token\", None)\n        # add auth hook \n        self.dispatch_hooks.append(\"_hook_token_auth\")\n\n    def _hook_token_auth(self, method: str, *args: Any, **kwargs: Any) -&gt; Optional[ResponseReturnValue]:\n        if not self.auth_token:\n            # no token defined, allow access\n            return None\n\n        if \"x-access-key\" in request.headers:\n             if self.auth_token == request.headers['x-access-token']:\n                 # valid auth token \n                 return None\n\n        # Invalid auth token            \n        return self.forbidden()\n</code></pre>"},{"location":"http/extending_views/#hooks-in-mixins","title":"Hooks in Mixins","text":"<p>Pokie also supports Mixin initializers, that can be used to implement specific hook functionality. These initializers are called by name at the end of the init() function. These initializer methods can have any valid name and follow (**kwargs) as an interface:</p> <pre><code>from pokie.http import PokieView\nfrom flask import request\nfrom typing import Any, Optional\nfrom flask.typing import ResponseReturnValue\n\nclass TokenAuthMixin:\n\n    def init_auth(self, **kwargs):\n        self.dispatch_hooks.append(\"_hook_token_auth\")        \n\n    def _hook_token_auth(self, method: str, *args: Any, **kwargs: Any) -&gt; Optional[ResponseReturnValue]:\n        if not self.auth_token:\n            # no token defined, allow access\n            return None\n\n        if \"x-access-key\" in request.headers:\n             if self.auth_token == request.headers['x-access-token']:\n                 # valid auth token \n                 return None\n\n        # Invalid auth token            \n        return self.forbidden()\n\n\n# declare a class using the mixin\nclass MyView(PokieView, TokenAuthMixin):\n    # Add the Mixin initializer name to be called on __init__()\n    init_methods = [\"init_auth\",]\n</code></pre>"},{"location":"http/json_response/","title":"JsonResponse class","text":"<p>The JsonResponse provides a standard JSON response for both success and error responses. The data is automatically serialized using Rick's ExtendedJsonEncoder. As such, uuid objects, datetime objects and FieldMapper records are supported.</p> <p>Generated JSON Response format:</p> Name Type Mandatory - success Mandatory - error Description success bool yes yes operation result status data any yes no returned data - may be empty on empty responses error any (default dict) no yes returned error on failure <p>Success response example: <pre><code>{\n\"success\": true,\n\"data\": (... JSON-encoded response ...)\n}\n</code></pre></p> <p>Error response example (without a specific error payload): <pre><code>{\n\"success\": false,\n\"error\": {\n\"message\": \"an error has occurred\"\n}\n}\n</code></pre></p>"},{"location":"http/rest/","title":"REST Views","text":"<p>Pokie provides several helpers to implement REST endpoints; one of them is the RestView class. This class implements all the basic REST operations for CRUD operations on a given Record/Service. Service can either be the generic pokie.rest.RestService, or a custom service that implements pokie.rest.RestServiceInterface.</p> <p>There are also advanced helpers that provide endpoint generation with a greater degree of automation, and based on pokie.rest.RestView. These helpers are described in detail in the Auto REST section.</p>"},{"location":"http/rest/#resource-based-rest-views-restview","title":"Resource-based REST views - RestView","text":"<p>The pokie.rest.RestView provides the basic CRUD functionality for a RickDb Record class, effectively allowing automatic creation of CRUD endpoints for database objects, while maintaining a three-tier architectural design.</p> <p>By default, RestView will attempt to create a pokie.rest.RestService instance, uniquely named by module and record class. However, if service_name is specified, the associated service will be used instead. Please note that services to be used with the RestView class need to extend from pokie.rest.RestServiceMixin.</p> <p>RestView example:</p> <pre><code>from pokie.rest import RestView\nfrom rick.form import RequestRecord, field\nfrom rick_db import fieldmapper\n\n\n# DB Record class\n@fieldmapper(tablename=\"country\", pk=\"country_id\", schema=\"public\")\nclass CountryRecord:\n    id = \"country_id\"\n    country = \"country\"\n\n\n# RequestRecord class\nclass CountryRequest(RequestRecord):\n    fields = {\n        \"id\": field(validators=\"id|numeric\", bind=\"id\"),\n        \"country\": field(validators=\"required\", bind=\"country\")\n    }\n\n\n# REST view class\nclass CountryView(RestView):\n    # RequestRecord class for body operations\n    request_class = CountryRequest\n\n    # Database Record class\n    record_class = CountryRecord\n\n    # allowed search fields to be used with the search variable\n    search_fields = [CountryRecord.country]\n\n    # optional custom service name to be used; if no service name is specified, an instance of\n    # pokie.rest.RestService is automatically created\n    # service_name = \"my-service-name\"\n\n    # optional limit for default listing operations\n    # if list_limit &gt; 0, the specified value will be used as default limit for unbounded listing requests\n    # list_limit = -1    \n</code></pre>"},{"location":"http/rest/#using-restview-grid-capabilities","title":"Using RestView grid capabilities","text":"<p>By leveraging DbGrid capabilities through a DbGridRequest object, the RestView offers a set of relevant features for advanced scenarios, such as server-side pagination, sorting and search.</p> <p>the following url variables are available:</p> Variable Format Example Description - - /url List all records, see response type below offset /url?offset=5 List records starting at specified zero-based offset limit /url?limit=5 List limit amount of records search /url?search=foo List search results for search expression match field:value|other_field:other_value[...|field...] /url?match=age:22|gender:M List records with exact match on the set of conditions presented sort field:asc,field:desc /url?sort=name:asc,age:desc Sort records by specified conditions"},{"location":"http/rest/#using-offset-limit","title":"Using offset, limit","text":"<p>Offset and limit behave like their SQL counterparts - zero-based integer numbers specifying an absolute value. They can be combined to perform pagination:</p> <pre><code># pagination with 10 records per page\n/url?offset=10&amp;limit=10\n</code></pre>"},{"location":"http/rest/#using-search","title":"Using search","text":"<p>Search is performed in all fields specified in the view class search_fields attribute. The search is performed as case-insensitive %expression%, allowing for matches inside strings. If multiple fields are specified in search_fields, the search is performed with OR concatenation - the result record list is the combination of all individual matches on each field. Some of the internals of the search behaviour can be overridden by providing a custom Service class that extends the pokie.rest.RestServiceMixin mixin and overrides the list() method implementation.</p>"},{"location":"http/rest/#using-sort","title":"Using sort","text":"<p>Sort can be performed on multiple fields at once, and sort order can either be 'asc' or 'desc' in case-insensitive form.</p>"},{"location":"http/rest/#default-operation-and-mixing-multiple-options","title":"Default operation and mixing multiple options","text":"<p>By default, a naked GET request to the listing endpoint will return all records; However, this may not be desirable when the dataset size is bigger than a few hundred rows. It is possible to cap the default listing to a given number of rows by changing the list_limit class attribute.</p> <p>All or part of the specified options can be combined in a single request, to perform a server-side sorting &amp; filtering procedure.</p> <p>Querying an endpoint with curl, using offset, limit, search and sort on the records:</p> <pre><code>$ curl -X GET -H 'Content-Type: application/json' http://127.0.0.1:5000/my_url?offset=10&amp;limit=10&amp;search=john&amp;sort=name:desc\n</code></pre>"},{"location":"http/rest/#response-format","title":"Response format","text":"<p>All RestView operations return a variable JSON dataset with the following structure:</p> <pre><code>{\n\"total\": 110,\n\"items\": [\n...list\nof\nrecord\nobjects...\n]\n}\n</code></pre> <p>Where total is the total amount of rows on the source dataset, ignoring offset and limit constraints, allowing the implementation of server-side pagination.</p>"},{"location":"http/rest/#registering-routes","title":"Registering routes","text":"<p>The traditional approach is to register the desired routes in the build() method of the Module class in module.py of your specific module, by using either traditional Flask routes or AutoRouter:</p> <pre><code>(...)\n\n\nclass Module(BaseModule):\n    (...)\n\n    def build(self, parent=None):\n        # get Flask application\n        app = parent.app\n        # register desired routes\n        app.add_url_rule('/v1/my-rest-endpoint', methods=['GET', 'POST'],\n                         view_func=MyRestView.as_view('my-rest-endpoint'))\n        (...)\n</code></pre> <p>These routes are created when the module is loaded, so these operations are performed during the initialization of the application. Please note that using Flask route decorators - while possible - it is not supported nor recommended.</p> <p>RestView views can be added to the router using the traditional Flask approach; however, this process often envolves needless creation of similar code. To simplify this process, the pokie.http.AutoRouter class can be used to automate the registration of all endpoints at once:</p> <pre><code>from pokie.http import AutoRouter\nfrom pokie.rest import RestView\nfrom rick.form import RequestRecord, field\nfrom rick_db import fieldmapper\n\n\n# DB Record class\n@fieldmapper(tablename=\"country\", pk=\"country_id\", schema=\"public\")\nclass CountryRecord:\n    id = \"country_id\"\n    country = \"country\"\n\n\n# RequestRecord class\nclass CountryRequest(RequestRecord):\n    fields = {\n        \"id\": field(validators=\"id|numeric\", bind=\"id\"),\n        \"country\": field(validators=\"required\", bind=\"country\")\n    }\n\n\n# REST view class\nclass CountryView(RestView):\n    pass\n\n\n(...)\n\n# in our module's module.py:\n(...)\n\n\nclass Module(BaseModule):\n    (...)\n\n    def build(self, parent=None):\n        # register all routes automatically\n        AutoRouter.resource(parent.app, \"country\", CountryView)\n</code></pre> <p>The following routes will be registered:</p> Url Method Description /country GET List records /country POST Create record /country/:id_record GET Get record by id /country/:id_record PUT Update record /country/:id_record PATCH Update record /country/:id_record DELETE Delete record <p>Please note that AutoRouter doesn't verify if the binding method receives the appropriate arguments, so always make sure that the method signature is preserved when overriding it.</p> <p>Classes may not implement all available methods for resource manipulation; AutoRouter will only define routes for existing methods whose name match the resource operation - get, post, put, delete, or - alternatively - the controller operation - list, show, create, update, delete.</p>"},{"location":"http/rest/#autorouter-id_record-type","title":"AutoRouter id_record type","text":"<p>By default, AutoRouter defines id_record as an int value; This can, however, be changed to any Flask supported data type:</p> <pre><code>(...)\n\n\n# RequestRecord class\nclass CountryRequest(RequestRecord):\n    fields = {\n        \"id\": field(validators=\"required|maxlen:4\", bind=\"id\"),\n        \"country\": field(validators=\"required\", bind=\"country\")\n    }\n\n\n# REST view class\nclass CountryView(RestView):\n    pass\n\n\n(...)\n# in our module's module.py:\n(...)\n\n\nclass Module(BaseModule):\n    (...)\n\n    def build(self, parent=None):\n        # register all routes automatically, but id_record is of type string\n        AutoRouter.resource(parent.app, \"country\", CountryView, \"string\")\n</code></pre>"},{"location":"http/rest/#controller-style-rest-views","title":"Controller-style REST views","text":"<p>Pokie also support Controller-style REST views - views where the handler of a given HTTP method can have a custom name. Pokie's base view, pokie.http.PokieView already provides out-of-the-box support for these view types:</p> <pre><code># in our view file\nfrom pokie.http import PokieView\n\n\n# our Controller class:\nclass CustomerController(PokieView):\n\n    # instead of get(self, id_customer:str=None), we can give it a custom name\n    def view_customer(self, id_customer: str):\n\"\"\"\n        Get customer record\n        :param id_customer: \n        :return: \n        \"\"\"\n        # attempt to fetch record from our existing customer service\n        record = self.svc_customer().get_customer(id_customer)\n        if not record:\n            return self.not_found()\n\n        # return record if exists\n        return self.success(record)\n\n    def svc_customer(self):\n        return self.get_service(MY_CUSTOMER_SERVICE_CONSTANT)\n\n\n(...)\n\n# in our module's module.py:\n(...)\n\n\nclass Module(BaseModule):\n    (...)\n\n    def build(self, parent=None):\n        # register a custom route for the class method called \"view_customer\"\n        app = parent.app\n        app.add_url_rule(\n            \"/v1/customer/&lt;string:id_customer&gt;\",\n            methods=[\"GET\"],\n            view_func=CustomerController.view_method(\"view_customer\"),\n        )\n</code></pre>"},{"location":"http/rest/#using-autorouter-with-controllers","title":"Using AutoRouter with Controllers","text":"<p>pokie.http.AutoRouter also provides automatic route registration for controller classes, if they implement the appropriate methods:</p> Method name Method signature HTTP operation list list(self) GET show show(self, id_record) GET create create(self) POST update update(self, id_record) PUT, PATCH delete delete(self, id_record) DELETE <p>The route registration will only map existing methods:</p> <pre><code># in our view file\nfrom pokie.http import PokieView\n\n\n# our Controller class:\nclass CustomerController(PokieView):\n\n    # GET handler for customer record\n    def show(self, id_record: str):\n\"\"\"\n        Get customer record\n        :param id_record: \n        :return: \n        \"\"\"\n        # attempt to fetch record from our existing customer service\n        record = self.svc_customer().get_customer(id_record)\n        if not record:\n            return self.not_found()\n\n        # return record if exists\n        return self.success(record)\n\n    # GET handler for customer listing operations \n    def list(self):\n        pass\n\n    def svc_customer(self):\n        return self.get_service(MY_CUSTOMER_SERVICE_CONSTANT)\n\n\n(...)\n\n# in our module's module.py:\n(...)\n\nclass Module(BaseModule):\n    (...)\n\n    def build(self, parent=None):\n\n        # register all available controller routes for class CustomerController:\n        # /customer [GET] -&gt; CustomerController.list()\n        # /customer/&lt;string:id_record&gt; [GET] -&gt; CustomerController.show()        \n        AutoRouter.controller(parent.app, \"customer\", CustomerController, \"string\")\n</code></pre>"},{"location":"http/views/","title":"Pokie Views","text":"<p>Pokie extends on the class-based views on Flask, and offers additional features such as automatic request body unmarshall, custom-named view methods (a-la Controllers), response helpers and authentication.</p> <p>Using Pokie views is not mandatory; however, they are quite handy to implement REST-based APIs, and they provide extra degrees of automation and JSON interaction.</p>"},{"location":"http/views/#using-pokieview","title":"Using PokieView","text":"<p>PokieView is the base view class of Pokie. This class implements the following functionalities:</p> <ul> <li>optional automatic body deserialization and validation with a RequestRecord class;</li> <li>pre-dispatch hook system;</li> <li>json-first exception handler;</li> <li>json helpers;</li> </ul>"},{"location":"http/views/#body-deserialization-validation","title":"Body deserialization &amp; validation","text":"<p>The request body can be automatically deserialized and validated for specific http methods (POST, PUT, PATCH) by specifying a RequestRecord class in the request_class class attribute. If the submitted data fails validation, a RequestRecord error response is returned. If validation is successful, the handler method is called and the RequestRecord object instance can be accessed via self.request property.</p> <p>Simple example with a custom RequestRecord class and a POST handler:</p> <pre><code>from rick.form import RequestRecord, field\nfrom pokie.http import PokieView\n\n# JSON Request validation \nclass FilmRequest(RequestRecord):\n    fields = {\n        'id': field(validators='id|numeric'),\n        'title': field(validators='required'),\n        'description': field(validators=''),\n        'releaseYear': field(validators='numeric'),\n        'rating': field(validators=''),\n        'lastUpdate': field(validators='required|iso8601'),\n        'sinopse': field(validators='maxlen:2048'),\n    }\n\n\nclass FilmView(PokieView):\n    # use FilmRequest for automatic body deserialization and validation\n    request_class = FilmRequest\n\n    def post(self):\n\n        print(\"submitted data:\")\n        #retrieve dict with all submitted values\n        print(self.request.get_data())\n\n        # return a standard JSON success response with code 200:\n        # {\"success\":true,\"message\":\"\"}\n        return self.success() \n</code></pre>"},{"location":"http/views/#custom-response-objects","title":"Custom Response objects","text":"<p>PokieView responses are traditionally either JsonResponse or CamelCaseJsonResponse objects; however, it is quite simple to override the default response class to use your own custom implementation - just extend pokie.http.ResponseRendererInterface, and refer it in your view, using the response_class attribute: </p> <pre><code>from pokie.http import PokieView, ResponseRendererInterface\n\n\nclass HamburgerResponse(ResponseRendererInterface):\n\n    def assemble(self, _app, **kwargs):\n        # our custom Response only returns \"hamburger\"\n        return \"hamburger\"\n\n\nclass CustomResponseView(PokieView):\n    # custom response class to be used, intead of the default one\n    response_class = HamburgerResponse\n\n    def get(self):\n        # just generate a response\n        return self.success()\n</code></pre>"},{"location":"http/views/#camelcase-response","title":"CamelCase response","text":"<p>PokieView can, automatically, convert keys from the snake_case notation to camelCase before assembling the JSON response. This functionality is provided by the pokie.http.CamelCaseJsonResponse class, and is controlled by the PokieView.camel_case attribute:</p> <pre><code>from pokie.http import PokieView\nfrom pokie_test.dto import CustomerRecord\n\n\nclass CamelCaseResponseView(PokieView):\n    # enable automatic camelCasing of responses    \n    camel_case = True\n\n    def get(self):\n        record = CustomerRecord(\n            company_name=\"company_name\",\n            contact_name=\"contact_name\",\n            contact_title=\"contact_title\",\n            address=\"address\"\n\n        )\n        return self.success(record)\n</code></pre> <p>Generated response: <pre><code>{\n\"success\":true,\n\"data\":{\n\"address\":\"address\",\n\"companyName\":\"company_name\",\n\"contactName\":\"contact_name\",\n\"contactTitle\":\"contact_title\"\n}\n}\n</code></pre></p>"},{"location":"http/views/#custom-pre-dispatch-hooks","title":"Custom pre-dispatch hooks","text":"<p>Pre-dispatch hooks work as middlweware methods - they can be used to perform additional validations. If a given hook returns a ResponseReturnValue, the dispatch exits with the specified response. If a hook is run successfully, it should return None.</p> <p>Example: <pre><code>from rick.form import RequestRecord, field\nfrom pokie.http import PokieView\n\n# JSON Request validation \nclass FilmRequest(RequestRecord):\n    fields = {\n        'id': field(validators='id|numeric'),\n        'title': field(validators='required'),\n        'description': field(validators=''),\n        'releaseYear': field(validators='numeric'),\n        'rating': field(validators=''),\n        'lastUpdate': field(validators='required|iso8601'),\n        'sinopse': field(validators='maxlen:2048'),\n    }\n\n\nclass FilmView(PokieView):\n    # use FilmRequest for automatic body deserialization and validation\n    request_class = FilmRequest\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # add hook method to the hook list\n        self.dispatch_hooks.append('_my_hook')\n\n    def _my_hook(self, method: str, *args: Any, **kwargs: Any) -&gt; Optional[ResponseReturnValue]:\n\"\"\"\n        Custom hook to be executed on dispatch\n        \"\"\"\n        if method == 'get':\n            return self.error('We are blocking GET requests via dispatch hooks')\n        return None\n\n    def post(self):\n\n        print(\"submitted data:\")\n        #retrieve dict with all submitted values\n        print(self.request.get_data())\n\n        # return a standard JSON success response with code 200:\n        # {\"success\":true,\"message\":\"\"}\n        return self.success() \n</code></pre></p>"},{"location":"rest/auto/","title":"Automatic REST generation","text":"<p>Common REST scenarios include CRUD interaction with a database object (a view, a table or a predefined query); these often involve a RequestRecord with request validation rules, a DTO Record representing the database object, a Service that implements domain logic, and obviously a RestView to implement the different endpoints.</p> <p>Pokie's rest.Auto helpers leverage the existing Code Generation mechanisms to generate in runtime the required classes for a barebones REST implementation. These classes can be incrementally overridden later, making them ideal in PoC and simple use cases. They can also be used to perform rapid prototyping - implementations can be done incrementally, starting with automatic helpers and gradually implementing the specific business logic.</p> <p>Note: The rest.Auto database functionality is only available for PostgreSQL databases. Some data types may not work well, and complex schemas may not be fully supported. </p> <p>Note: Code generated classes always use id as the name representing the primary key field on the database - e.g. a table with a field id_foo will be referenced on the DTO Record and the RequestRecord as id, and not id_foo</p>"},{"location":"rest/auto/#automatic-rest-from-dto","title":"Automatic REST from DTO","text":"<p>This mechanism enables the automatic creation of a RestView object based on a DTO Record representing a database object. It will automatically generate a Request object if none is specified, based on the existing database table referenced by the DTO Record. The generated View class can also extend either a custom base class or a set of mixins.</p>"},{"location":"rest/auto/#method-signature","title":"Method signature","text":"<p>Auto.rest(app: object, slug: str, dto_record: object, request_class: RequestRecord = None, service: str = None,         id_type: str = None, search_fields: list = None, allow_methods: list = None, base_cls: tuple = None,         mixins: tuple = None,  **kwargs)</p> Parameter Type Description app Flask Flask object slug str A endpoint url slug dto_record RickDB DTO Record A DTO Record to use request_class Rick RequestRecord An optional RequestRecord to use for input values service str An optional service to use instead of the automatically generated one id_type str The type of the record id for the urls, supported by Flask; defaults to \"int\" search_fields list Optional list of fields to perform text search; if omitted, all varchar/text fields are used allow_methods list If specified, will only allow the specified http methods base_cls class Optional base class to use instead of pokie.rest.RestView mixins tuple Optional tuple with additional mixins"},{"location":"rest/auto/#usage-example","title":"Usage example","text":"<p>A complete minimal application to expose a database table called customers as a REST endpoint: <pre><code>from rick_db import fieldmapper\nfrom rick.resource.config import EnvironmentConfig\nfrom pokie.config.template import BaseConfigTemplate, PgConfigTemplate\nfrom pokie.core import FlaskApplication\nfrom pokie.core.factories.pgsql import PgSqlFactory\nfrom pokie.rest.auto import Auto\n\n\n@fieldmapper(tablename=\"customers\", pk=\"customer_id\")\nclass CustomerRecord:\n    id = \"customer_id\" # this field is actually a varchar\n    company_name = \"company_name\"\n    contact_name = \"contact_name\"\n    contact_title = \"contact_title\"\n    address = \"address\"\n    city = \"city\"\n    region = \"region\"\n    postal_code = \"postal_code\"\n    country = \"country\"\n    phone = \"phone\"\n    fax = \"fax\"\n\n\n# config parameters, injectable from ENV vars\nclass Config(EnvironmentConfig, BaseConfigTemplate, PgConfigTemplate):\n    pass\n\n\n# Our custom route initialization to skip usage of modules\n# because Auto.rest() will require database access to the table customers, we need to postpone route registration\n# to the actual web initialization routines, as it is done with modules\ndef router(p: FlaskApplication):\n    # Auto.rest() will generate all required classes and register the following routes:\n    # /customer                     OPTIONS,HEAD,GET\n    # /customer/&lt;string:id_record&gt;  OPTIONS,HEAD,GET\n    # /customer                     POST,OPTIONS\n    # /customer/&lt;string:id_record&gt;  OPTIONS,PUT,PATCH\n    # /customer/&lt;string:id_record&gt;  OPTIONS,DELETE\n    Auto.rest(p.app,  # our Flask app\n              \"customer\",  # the base slug\n              CustomerRecord,  # the DTO to use\n              search_fields=[CustomerRecord.company_name, CustomerRecord.contact_name],  # fields to allow text search\n              id_type=\"string\" # type of id_record to use\n              )\n\n\ndef build_pokie():\n    # load configuration from ENV\n    cfg = Config().build()\n\n    # modules to load &amp; initialize\n    modules = []\n\n    # factories to run\n    factories = [PgSqlFactory, ]\n\n    # build app\n    pokie_app = FlaskApplication(cfg)\n    flask_app = pokie_app.build(modules, factories)\n    # register our route initializer to be used only on web context\n    pokie_app.register_pre_http_hook(router)\n\n    return pokie_app, flask_app\n\n\nmain, app = build_pokie()\n\n# =============================================================================\n\nif __name__ == '__main__':\n    main.cli()\n</code></pre></p> <p>While it is possible to build single-file applications with Pokie, the most common scenario is to build modular applications. When using modules, Auto.rest is commonly used in the build() section of your module.py:</p> <pre><code>from pokie.core import BaseModule\nfrom pokie.rest.auto import Auto\nfrom pokie_test.dto.records import CustomerRecord\n\n\nclass Module(BaseModule):\n    # internal module name\n    name = \"my_module\"\n\n    (...)\n\n    def build(self, parent=None):\n        app = parent.app\n\n        # Auto.rest() will generate all required classes and register the following routes:\n        # /customer                     OPTIONS,HEAD,GET\n        # /customer/&lt;string:id_record&gt;  OPTIONS,HEAD,GET\n        # /customer                     POST,OPTIONS\n        # /customer/&lt;string:id_record&gt;  OPTIONS,PUT,PATCH\n        # /customer/&lt;string:id_record&gt;  OPTIONS,DELETE\n        Auto.rest(app,  # our Flask app\n                  \"customer\",  # the base slug\n                  CustomerRecord,  # the DTO to use\n                  # fields to allow text search\n                  search_fields=[CustomerRecord.company_name, CustomerRecord.contact_name],\n                  id_type=\"string\"  # type of id_record to use\n                  )\n        (...)\n</code></pre>"},{"location":"rest/auto/#automatic-rest-from-database-table","title":"Automatic REST from Database Table","text":"<p>It is possible to just skip the usage of a DTO Record and have the framework build one instead in runtime, from an existing database table; Auto.view() will generate a RestView class for the specified table, that can be registered using the AutoRouter or  traditional Flask route registration mechanisms.</p>"},{"location":"rest/auto/#method-signature_1","title":"Method signature","text":"<p>Auto.view(app: object, table_name: str, schema: str = None, search_fields: List = None, camel_case: bool = False,         allow_methods: list = None, base_cls: tuple = None, mixins: tuple = None, **kwargs) -&gt; PokieView:</p> Parameter Type Description app Flask Flask object table_name str Database table name to use schema str Optional database  schema search_fields list Optional list of fields to perform text search; if omitted, all varchar/text fields are used camel_case bool If true, dict keys are camelCased allow_methods list If specified, will only allow the specified http methods base_cls class Optional base class to use instead of pokie.rest.RestView mixins tuple Optional tuple with additional mixins"},{"location":"rest/auto/#usage-example_1","title":"Usage example","text":"<p>A complete minimal application to expose a database table called customers as a REST endpoint:</p> <pre><code>from rick.resource.config import EnvironmentConfig\nfrom pokie.config.template import BaseConfigTemplate, PgConfigTemplate\nfrom pokie.core import FlaskApplication\nfrom pokie.core.factories.pgsql import PgSqlFactory\nfrom pokie.http import AutoRouter\nfrom pokie.rest.auto import Auto\n\n\n# config parameters, injectable from ENV vars\nclass Config(EnvironmentConfig, BaseConfigTemplate, PgConfigTemplate):\n    pass\n\n\n# Our custom route initialization to skip usage of modules\n# because Auto.rest() will require database access to the table customers, we need to postpone route registration\n# to the actual web initialization routines, as it is done with modules\ndef router(p: FlaskApplication):\n    # Auto.view() will generate a view for the customers table\n    view = Auto.view(app, \"customers\", search_fields=[\"company_name\", \"contact_name\"])\n    # and AutoRouter.resouce() registers the following endpoints:\n    # /customer                     HEAD,GET,OPTIONS\n    # /customer/&lt;string:id_record&gt;  HEAD,GET,OPTIONS\n    # /customer                     OPTIONS,POST\n    # /customer/&lt;string:id_record&gt;  PATCH,PUT,OPTIONS\n    # /customer/&lt;string:id_record&gt;  DELETE,OPTIONS\n    AutoRouter.resource(p.app, \"customer\", view, id_type=\"string\")\n\n\ndef build_pokie():\n    # load configuration from ENV\n    cfg = Config().build()\n\n    # modules to load &amp; initialize\n    modules = []\n\n    # factories to run\n    factories = [PgSqlFactory, ]\n\n    # build app\n    pokie_app = FlaskApplication(cfg)\n    flask_app = pokie_app.build(modules, factories)\n    pokie_app.register_pre_http_hook(router)\n\n    return pokie_app, flask_app\n\n\nmain, app = build_pokie()\n\n# =============================================================================\n\nif __name__ == '__main__':\n    main.cli()\n</code></pre> <p>While it is possible to build single-file applications with Pokie, the most common scenario is to build modular applications. As it happens with Auto.rest(), Auto.view is commonly used in the build() section of your module.py:</p> <pre><code>from pokie.core import BaseModule\nfrom pokie.rest import Auto\nfrom pokie.http import AutoRouter\n\n\nclass Module(BaseModule):\n    # internal module name\n    name = \"my_module\"\n\n    (...)\n\n    def build(self, parent=None):\n        app = parent.app\n\n        # Auto.view() will generate a view for the customers table\n        view = Auto.view(app, \"customers\", search_fields=[\"company_name\", \"contact_name\"])\n        # and AutoRouter.resouce() registers the following endpoints:\n        # /customer                     HEAD,GET,OPTIONS\n        # /customer/&lt;string:id_record&gt;  HEAD,GET,OPTIONS\n        # /customer                     OPTIONS,POST\n        # /customer/&lt;string:id_record&gt;  PATCH,PUT,OPTIONS\n        # /customer/&lt;string:id_record&gt;  DELETE,OPTIONS\n        AutoRouter.resource(p.app, \"customer\", view, id_type=\"string\")\n        (...)\n</code></pre>"},{"location":"rest/services/","title":"REST services","text":"<p>Pokie provides several mixins to help with the implementation of REST services; These mixins rely on DTO Objects and Repositories to provide the common CRUD and listing  functions.</p>"},{"location":"rest/services/#pokierestrestservicemixin","title":"pokie.rest.RestServiceMixin","text":"<p>This mixin provides minimal CRUD functionality on top of a implementation-defined Repository; it can be used as a base implementation when prototyping services, as it enables gradual replacement of existing base behaviours with more complex implementations at a later stage in the development cycle. </p> <p>The mixin provides the following methods:</p> Method Result Description get(id_record) DTO Record if exists, None if not Fetch a record by primary key delete(id_record) None Remove a record by primary key insert(self, record) primary key value Insert a new record update(id_record, record) None Update a record by primary key exists(id_record) True or False Check if a record with the specified primary key exists list(...)* tuple(total_count, rows) Perform a listing operation based on the specified criteria <ul> <li>list() uses DbGrid internally; check REST Views for more details. </li> </ul> <p>To make use of this mixin, just make sure your service inherits pokie.rest.RestServiceMixin and provides a  a repository property returnung a valid Repository object:</p> <pre><code>from pokie.constants import DI_DB\nfrom rick.mixin import Injectable\nfrom rick_db import Repository\nfrom pokie.rest import RestServiceMixin\nfrom my_fancy_app.dto import MyFancyRecord\n\n\nclass MyFancyService(Injectable, RestServiceMixin):\n\n    @property\n    def repository(self) -&gt; Repository:\n        return Repository(self.get_di().get(DI_DB), MyFancyRecord)\n</code></pre>"},{"location":"rest/services/#pokierestrestservice","title":"pokie.rest.RestService","text":"<p>RestService is the service implementation used on REST Views. It can also be used independently to build custom services - just fill record_class with your desired DTO Record class  (and optionally repository_class with your custom Repository class); If no repository is specified, RestService will automatically build a generic Repository object based on record_class:</p> <p><pre><code>from pokie.rest import RestService\nfrom my_fancy_app.dto import MyFancyRecord\nfrom my_fancy_app.repository import MyFancyRepository\n\nclass MyFancyService(RestService):\n    # specify DTO Record class to use\n    record_class = MyFancyRecord\n    # specify a custom Repository class to use\n    #repository_class = MyFancyRepository\n</code></pre> RestService can also be used to build custom services in runtime - in fact, it is what RestView does internally -  it builds a generic RestService and adds it to the Service Locator:</p> <pre><code>from pokie.constants import DI_SERVICES\nfrom pokie.rest import RestService\nfrom pokie.http import PokieView\nfrom my_fancy_app.dto import MyFancyRecord\n\nclass MyView(PokieView):\n\n    def svc_custom(self) -&gt; RestService:\n        service_name = \"my_custom_service_name\"\n        service_manager = self.di.get(DI_SERVICES)\n\n        if not service_manager.contains(service_name):        \n            # create new service object\n            svc = RestService(self.di) \n            # set the DTO Record class\n            svc.set_record_class(MyFancyRecord)\n            # register the new service in the service manager    \n            service_manager.register(service_name, svc)\n\n            return svc\n\n        return service_manager.get(service_name)\n</code></pre>"},{"location":"test/pytest/","title":"Writing tests with pytest","text":"<p>Pokie includes a set of plugins to aid unit testing of applications with pytest, including a CLI runner. These plugins provide Pokie-related fixtures and, optionally, automatic database management.</p> <p>To use the pytest integration, it is required to use the application factory to initialize the application, see  the tutorial for more details.</p> <p>Currently, only PostgreSQL is supported for database operations; the configured database user must have database creation/drop privileges; The plugins also assume the user can connect to the database 'postgres', as it is used as the default db for administrative operations.</p> <p>Note: To use Pokie's unit testing capabilities, you need to install pytest </p>"},{"location":"test/pytest/#pokie-configuration","title":"Pokie Configuration","text":"<p>There are several test-related configuration parameters available to control execution of tests, exposed via pokie.config.TestConfigTemplate:</p> Parameter Description TEST_DB_NAME PostgreSQL test database name TEST_DB_HOST PostgreSQL host TEST_DB_PORT PostgreSQL port TEST_DB_USER PostgreSQL user TEST_DB_PASSWORD PostgreSQL password TEST_DB_SSL if True, enforces SSL TEST_MANAGE_DB if False, no db is managed via pytest-pokie TEST_SHARE_CTX if False, create a new application instance between tests (default) TEST_DB_REUSE if False, drops and recreates the database between tests (default) TEST_SKIP_MIGRATIONS if False, runs migrations when creating the database TEST_SKIP_FIXTURES if False, runs fixtures when creating the database"},{"location":"test/pytest/#application-lifecycle-parameters","title":"Application lifecycle parameters","text":"<p>TEST_SHARE_CTX</p> <p>False (default): Each test is run with a separate application instance; the application is bootstrapped at each test, by using the existing application factory.</p> <p>True: All tests are run with the same pokie FlaskApplication and Flask instance; services, events, etc. will be managed and cached as in a production run.</p>"},{"location":"test/pytest/#database-management","title":"Database management","text":"<p>Please note: The credentials provided to the test database must have enough privileges for the required operations, such as creating and dropping databases.</p> <p>TEST_MANAGE_DB</p> <p>False (default): If TEST_MANAGE_DB is False, database management is completely ignored, and available db connection is the regular application connection. All database test configurations are ignored. With this mode, it is up to the developer to ensure a clean state between database runs.</p> <p>True: If TEST_MANAGE_DB is True, pytest-pokie will manage the database connection using the available test credentials. The global database connection is replaced with the test connection, and fixtures and migrations may be executed between tests.</p> <p>TEST_DB_REUSE</p> <p>False (default): if TEST_DB_REUSE is False, pytest-pokie will attempt to drop and recreate the test database between each test.</p> <p>True: if TEST_DB_REUSE is True, pytest-pokie will not drop the testing database if exists. If it doesn't exist, it will attempt to create the database and optionally run migrations and fixtures, depending on TEST_SKIP_MIGRATIONS and TEST_SKIP_FIXTURES values.</p> <p>TEST_SKIP_MIGRATIONS</p> <p>False (default): Existing SQL migrations will be run when the database is recreated.</p> <p>True: Existing SQL migrations are ingored, even if the database is recreated.</p> <p>TEST_SKIP_FIXTURES</p> <p>False (default):Existing fixtures will be run when the database is recreated.</p> <p>True: Existing fixtures are ignored, even if the database is recreated.</p>"},{"location":"test/pytest/#available-fixtures","title":"Available fixtures","text":"<p>Note: fixtures depend on the predefined values for the different DI constants as specified on the pokie.constants file.</p> Fixture Description pokie_app Pokie Flask object pokie_config Pokie Config object pokie_di Pokie Di object pokie_db Pokie Database client pokie_client Flask test client"},{"location":"test/pytest/#writing-tests","title":"Writing Tests","text":"<p>Pytest must be invoked using the internal Pokie pytest runner. The pytest runner will automatically add the required dependencies to pytest. All additional pytest command-line arguments can be specified:</p> <pre><code>$ python main.py pytest --help\n\n[Pokie] Running pytest with: ['--help']\nusage: main.py [options] [file_or_dir] [file_or_dir] [...]\n\npositional arguments:\n  file_or_dir\n\ngeneral:\n  -k EXPRESSION         only run tests which match the given substring expression. An expression is a python evaluatable expression where all names are substring-matched against test names and their parent classes. Example: -k\n                        'test_method or test_other' matches all test functions and classes whose name contains 'test_method' or 'test_other', while -k 'not test_method' matches those that don't contain 'test_method' in their names. -k\n                        'not test_method and not test_other' will eliminate the matches. Additionally keywords are matched to classes and functions containing extra names in their 'extra_keyword_matches' set, as well as functions which\n                        have names assigned directly to them. The matching is case-insensitive.\n  -m MARKEXPR           only run tests matching given mark expression.\n                        For example: -m 'mark1 and not mark2'.\n  --markers             show markers (builtin, plugin and per-project ones).\n  -x, --exitfirst       exit instantly on first error or failed test.\n  --fixtures, --funcargs\n(...)\n$\n</code></pre> <p>The scaffold structure is similar to the common pytest usage:</p> <pre><code>some_module/\n  (...)\nmain.py\ntests/\n  __init__.py\n  some_module/\n    __init__.py\n    test_something.py  </code></pre> <p>test_something.py:</p> <pre><code>def test_example_1(pokie_app, pokie_di):\n    assert pokie_app is not None\n    assert pokie_app.di == pokie_di\n\n\ndef test_example_2(pokie_db, pokie_service_manager):\n    assert pokie_db is not None\n    assert pokie_service_manager is not None\n</code></pre> <p>And to run the tests:</p> <pre><code>$ python3 main.py pytest\n</code></pre>"},{"location":"test/pytest/#using-tox","title":"Using tox","text":"<p>Example tox.ini:</p> <pre><code>[tox]\nenvlist =\npy39\npy310\n\n[testenv]\ndeps = -rrequirements-dev.txt\ncommands = python3 main.py pytest\n</code></pre> <p>Example requirements-dev.txt:</p> <pre><code>pytest==7.3.1\npokie==1.0.0\ntox==4.5.1\n</code></pre> <p>Running tox:</p> <pre><code>$ tox -e py310\n</code></pre>"},{"location":"tutorial/architecture/","title":"Pokie Architecture","text":"<p>Pokie promotes both two-tier and three-tier designs with heavy decoupling, in line with both  clean architecture principles and onion architecture principles. The goal is to have only pure object records being carried through the layers, such as RickDB's DTO Objects. Communication is performed strictly top-down: each layer can only interect with the one immediately below,</p> <p>A typical three-tier design has the following layers:</p>"},{"location":"tutorial/architecture/#presentation-layer","title":"Presentation layer","text":"<p>This is the level where Flask views are implemented, using class-based definitions; It is responsible for receiving requests, invoking dependencies, and assembling responses; No specific business-related logic should reside here, adhering to the philosophy of \"thin controllers\".</p> <p>As a default, these classes are instantiated as short-lived objects, and often only exist during the execution of a request, being  destroyed afterward. As such, all required initialization boilerplate must be as lightweight as possible. </p> <p>To override this behaviour and allow for long-lived view objects, please refer to the Flask documentation.  </p>"},{"location":"tutorial/architecture/#service-layer","title":"Service layer","text":"<p>The service layer provides internal complex functionality to the presentation layer or for internal operation of the application. Services are long-lived (by default atmost one instance created per service), but lazy-loaded - they are only created if invoked for.</p> <p>Services cannot interact with the Presentation layer; they are invoked (via service locator) from the Presentation layer;  the service method signature may or may not be part of a formal interface, depending on design requirements.</p> <p>Services can interact with other services, as well as with the data layer, immediately below. Also, it is quite common to implement caching at the service level.</p> <p>Keep in mind, services are - from a caller's perspective - stateless; they have no context of the application  (eg. if its http or console, what is the current user session, etc), and all operations are - from a caller's perspective - atomic. As such, if cache is implemented, it is up to the internal implementation of the service to ensure cache consistency in such a way the service retains its stateless and context-less properties.</p> <p>Services are invoked by a generic name, via a MapLoader object acting as a service locator. The service classes must inherit the Injectable mixin. </p>"},{"location":"tutorial/architecture/#data-layer","title":"Data layer","text":"<p>The data layer provides basic data operations; this is often achieved by using RickDb's Repository pattern, and DTO Records. Due to the nature of the DTO  objects (data-only objects with no business logic or internal state), these can be passed upwards into the presentation layer.</p> <p>Repositories can either be short-lived or long-lived, depending on how they are use inside services; the most common approach is to have long-lived repositories defined as properties within the service.</p> <p>The instantiation of a repository is direct, but other mechanisms can be used if a greater degree of decoupling is required.</p>"},{"location":"tutorial/scaffolding/","title":"Application Scaffolding","text":"<p>Pokie applications are organized in modules; these modules reside in folders, and implement specific functionalities, and  have a custom startup script, often called main.py. This script is the main entry point for both web-specific operations and cli-specific operations. Even cli operations will have a full bootstrapped Flask application available.</p> <p>Modules are identified and referenced by name; their name is a string with their full python import path, relative to the main.py script.  The application can use both custom local modules and pre-packaged modules; In fact, a big portion of Pokie's functionality resides itself on a module - pokie.contrib.base.</p> <p>The module structure is identical to a python module, with a few assumptions: - there is always a file named module.py, containing a class called Module, extending BaseModule; - database migrations (if any) are sql files residing in a folder called sql; - modules can provide functionality without requiring web components or interacting with the Flask application; - there is no other requirement regarding module structure besides the optional sql folder and the module.py file; </p>"},{"location":"tutorial/scaffolding/#the-main-module-file-modulepy","title":"The main module file: module.py","text":"<p>This file contains the module initialization class, as well as all the resources made available on the module, including services, cli commands and worker jobs. The class itself must inherit from BaseModule.</p> <p>The module initialization is done in two stages - first, the object instantiation and reading of global attributes, and then, at a later stage, the build() method is called to initialize the module, and register any Flask views that are required for module operation.</p> <p>Keep in mind, as long as the module is initialized, all registered components - services, events, cli commands, worker jobs and migrations are fully working and made available to their respective manager objects.</p> <p>Annotated module.py example: <pre><code>from example.module.constants import SVC_SAMPLE\nfrom pokie.core import BaseModule\n\n\nclass Module(BaseModule):\n\n    # internal module name, must be unique\n    name = \"module\"\n\n    # internal module description\n    description = \"Example module\"\n\n    # service map\n    #\n    # this map registers existing module services, and makes them available to the application. Services are lazy-loaded\n    # upon first invocation, to reduce overhead. A service class must inherit the Injectable mixin.\n    #\n    # The service mapper will load services by service name; As such, service names should be unique, unless the goal\n    # is to explicitly override already-registered services\n    #\n    services = {\n        # service entries are defined as {'service_name': 'path_to_class'}\n        SVC_SAMPLE: 'module.service.SampleService',\n    }\n\n    # cli command map\n    #\n    # this map registers existing cli commands exposed by the module. Cli commands are classes that inherit from \n    # CliCommand. Cli command names should be unique, unless the goal is to explicitly override existing commands\n    #\n    cmd = {\n        # cli commands are defined as {'command': 'path_to_class'}\n        'sample': 'module.cli.SampleCmd'\n    }\n\n    # events map\n    #\n    # Pokie has a concept similar to signals in other framework., but with different capabilities, called Events. Events\n    # are classes that extend from EventHandler, and implement a method with the name of the event. Event handler objects\n    # are short-lived - they are created upon dispatched of a given event, and de-referenced afterwards.\n    #\n    # Events have a priority number - handler execution follows the priority number in descending order (lower numbers get\n    # executed first)\n    # \n    # Events also have optional in and out objects, typically used for dictionary composition. A common use case is to add\n    # extra information to the response generated on a given information, such as login\n    #\n    # Event names are unique strings that identify the event; there is no specific requirements for naming, but common\n    # convention suggests the usage of snakecase (eg. some_event).\n    #\n    #\n    # events are refined as a two-level structure, containing zero or more events, and then handlers and priorities:\n    # events = {\n    #   'event_name': {\n    #       numeric_priority: [path_to_handler, path_to_handler, ...]\n    #   }\n    # }\n    #\n    events = {\n        'my_event_name': {\n            10: ['module.event.handler.ExampleEventHandler', ]\n        },\n    }\n\n    # worker jobs list\n    #\n    # jobs are tasks that are executed continuously and cooperatively, in a closed loop; their purpose is to execute\n    # background operations such as sending emails or resizing images. What makes them different from cron approaches\n    # is their continuous execution - there is an idle job with a default 15s pause, and then all other jobs are run\n    # sequentially, in a closed loop. If a given job takes too much time to execute, it will delay subsequent jobs, so\n    # this approach may not fit all workloads.\n    #\n    # Jobs are long-lived objects whose class must extend Injectable and Runnable mixins.\n    # The job list is a list of strings with the full path for each job class, similar to other existing referencing structures \n    #\n    jobs = [\n        # 'full.path.to.job.class'\n    ]\n\n    # fixture class list\n    #\n    # fixtures are objects that are run only once; They can be used to load initial/default values or to perform non-trivial\n    # database operations, such as data migrations\n    #\n    fixtures = [\n        # 'full.path.to.fixture.class'\n    ]\n\n    def build(self, parent=None):\n        # This method is called when modules are initialized; At this point, all other dependencies have already been\n        # initialized, including the Service Manager, Event Manager and even registered factories\n        #\n        # All Flask-related routing calls should reside here\n        pass\n</code></pre></p>"},{"location":"tutorial/scaffolding/#module-directory-structure","title":"Module directory structure","text":"<p>While there are no specific limitations on the module internal structure besides the already mentioned exceptions, a  typical recommended on-disk module layout for a complete module would be as follows: </p> <pre><code>my_project/\n    project_module/     &lt;- module called 'project_module'\n        cli/            &lt;- folder for cli command classes\n            __init__.py\n        dto/            &lt;- folder for DTO's (or RickDb Records)\n            __init__.py                                \n        event/          &lt;- folder for EventHandler classes\n            __init__.py\n        plugin/         &lt;- plugin folder\n            __init__.py                    \n        repository/     &lt;- RickDb Repository classes folder\n            __init__.py\n        service/        &lt;- folder for Service classes\n            __init__.py\n        sql/            &lt;- folder containing SQL migration scripts\n        view/           &lt;- folder for Flask views\n            __init__.py                                                            \n        __init__.py\n        module.py   &lt;- the module initialization class\n\n    other_module/   &lt;- other module\n        ...        \n    main.py         &lt;- the startup script\n</code></pre>"},{"location":"tutorial/tutorial/","title":"Pokie Tutorial","text":""},{"location":"tutorial/tutorial/#foreword","title":"Foreword","text":"<p>Pokie is built upon Dependency Injection and Resource Location. As such, dependencies are often specified by a full class path string, instead of a direct import; coupling is inferred in runtime via provided configuration, instead of more traditional approaches of using imports to provide dependencies. One of the main advantages of this approach is the quasi-elimination of circular imports problem, and provides an elegant mechanism of overriding dependencies either at load time or in runtime.</p> <p>Pokie also makes heavy use of classes and namespaces, and often each class will reside in its own file; this requires more discipline when scaffolding an application, and (sometimes) writing classes is more verbose than using more traditional approaches. This is a calculated tradeoff by design, and not just a mere consequence of heavy pattern usage.</p> <p>Contents:</p> <ul> <li>Architecture</li> <li>Scaffolding</li> </ul>"},{"location":"tutorial/tutorial/#initializing-the-application","title":"Initializing the application","text":"<p>To fully bootstrap the application, three components are required: the configuration container (a ShallowContainer instance, see below), the module list to be instantiated, and the factory list to be initialized.</p> <p>It is recommended the bootstrap itself is built inside a factory function with the name build_pokie(); by encapsulating  all the initialization within a single identified function, we can provide a clean application context to run unit  tests.</p> <p>The typical sequence of operations (both explicit and implicit) of a Pokie application is:</p> <ul> <li>load configuration; </li> <li>build base Flask app; </li> <li>load configured modules (instantiate Module objects only);</li> <li>build a service map and initialize the Service Manager;</li> <li>run factories defined in the factory list;</li> <li>parse event definitions from modules and build the Event Manager;</li> <li>run appropriate CLI wrapper, or pass app variable to a WSGI server;</li> <li>initialize modules (by calling build() on each Module object); </li> </ul>"},{"location":"tutorial/tutorial/#configuration","title":"Configuration","text":"<p>Pokie manages configuration using Rick's configuration resources - it supports both environment-variable based configuration or file-based configuration using JSON format. Both are parsed into a ShallowContainer object.</p>"},{"location":"tutorial/tutorial/#environment-based-configuration","title":"Environment-based configuration","text":"<p>Environment-based configuration is a Docker-friendly mechanism to provide configurations; The configuration class extends EnvironmentConfig, and when invoking build(), it attempts to read environment variables matching the existing uppercase-named  class attributes. If a match is found, the default value is replaced. </p> <p>In addition, if the default value is an object of type StrOrFile, it will consider the specified existing value a path to a file containing the actual value. Any StrOrFile attribute with a computed value (either default or injected via environment variables) that starts with / or ./ will be treated as a file to be read to determine the final value. </p> <p>Note: The return ShallowContainer object from Config.build() will have all keys in lowercase, including the ones defined  originally as uppercase. This allows the configuration class to have internal static configuration attributes that are not injectable from environment variables.</p> <p>Minimal Pokie environment-based configuration example:</p> <pre><code>from rick.resource.config import EnvironmentConfig\nfrom pokie.config.template import BaseConfigTemplate\n\n# minimal Pokie environment-based configuration\n# Pokie's defaults come from BaseConfigTemplate\nclass Config(EnvironmentConfig, BaseConfigTemplate):\n    pass\n\n# load configuration and return a ShallowContainer\ncfg = Config().build()\n</code></pre>"},{"location":"tutorial/tutorial/#file-based-configuration","title":"File-based configuration","text":"<p>File-based configuration is comparatively simpler, as all values are read from the specified file. However, default values for settings need also to exist on the file, resulting in more complex files.</p> <p>Minimal Pokie file-based configuration example:</p> <pre><code>from rick.resource.config import json_file\n\n# load configuration from file and return a ShallowContainer\ncfg = json_file('config.json')\n</code></pre> <p>config.json contents: <pre><code>{\n\"modules\": [],\n\"use_auth\": true,\n\"auth_plugins\": [\"pokie.contrib.auth.plugin.DbAuthPlugin\"],\n\"auth_secret\": \"very_secret_key\",\n\"db_cache_metadata\": false\n}\n</code></pre></p>"},{"location":"tutorial/tutorial/#module-initialization","title":"Module initialization","text":"<p>Bootstrapping a Pokie application requires a list of modules to be initialized; Each element of the list is a string with a python class path for the module itself; Each module directory must then contain a Module class that inherits from BaseModule, inside a file called module.py. This is the initialization class for a given module.</p> <p>The list of modules to be initialized can also be provided via configuration setting, depending on the desired implementation.</p>"},{"location":"tutorial/tutorial/#factory-initialization","title":"Factory initialization","text":"<p>Factories are assorted initializers for several purposes. One of them is to provide lazy loading mechanisms for database connections or cache connections. The factory list is a list of direct classes (python classes, not strings).</p>"},{"location":"tutorial/tutorial/#application-factory-build_pokie","title":"Application factory: build_pokie()","text":"<p>Usage of the main application factory is not mandatory, but essential if unit tests are required. Unit testing often requires the opposite strategy of a production application, in the sense that reusage and caching of objects should be avoided completely. To ensure this, the factory encapsulates the complete bootstrap of the application, in such a way  that can be called once per single test, ensuring that available internal resources are not reused. </p> <p>build_pokie() -&gt; Tuple[FlaskApplication, Flask]  Factory to build a pokie application and returns both the Pokie FlaskApplication object and the Flask object.</p>"},{"location":"tutorial/tutorial/#minimal-mainpy-example","title":"Minimal main.py example","text":"<p>The main.py script is usually a simple file, containing the previously mentioned components. In addition, it should also provide the cli wrapper, to automatically also be able to execute cli operations. To enable this feature, just add this to the bottom of the file:</p> <pre><code>if __name__ == '__main__':\n    main.cli()\n</code></pre> <p>A minimal  but complete main.py example: <pre><code>from rick.resource.config import EnvironmentConfig\n\nfrom pokie.config.template import BaseConfigTemplate, PgConfigTemplate\nfrom pokie.core import FlaskApplication\nfrom pokie.core.factories.pgsql import PgSqlFactory\nfrom pokie.core.factories.login import FlaskLogin\n\n\n# base configuration\nclass Config(EnvironmentConfig, BaseConfigTemplate, PgConfigTemplate):\n    pass\n\ndef build_pokie():\n    # load configuration from ENV\n    cfg = Config().build()\n\n    # modules to load &amp; initialize:\n    # the internal auth module, and a custom-defined local module called 'my_module'\n    modules = ['pokie.contrib.auth', 'my_module']\n\n    # factories to run\n    # the postgresql initializer, and the flask-login initializer\n    factories = [PgSqlFactory, FlaskLogin, ]\n\n    # build Pokie application\n    pokie_app = FlaskApplication(cfg)\n    # bootstrap Pokie application\n    # the returned object is a Flask application\n    flask_app = main.build(modules, factories)\n    return pokie_app, flask_app\n\n# main is reused for the cli wrapper\n# app is often reused as the WSGI Flask object \nmain, app = build_pokie()\n\n# if it is a cli invocation\nif __name__ == '__main__':\n    # run the cli wrapper\n    main.cli()\n</code></pre></p> <p>For development purposes, the application can be run directly: <pre><code>$ python3 main.py runserver -d -r\n * Serving Flask app 'FlaskApplication' (lazy loading)\n* Environment: production\n   WARNING: This is a development server. Do not use it in a production deployment.\n   Use a production WSGI server instead.\n * Debug mode: on\nINFO:werkzeug: * Running on http://127.0.0.1:5000 (Press CTRL+C to quit)\nINFO:werkzeug: * Restarting with watchdog (inotify)\nWARNING:werkzeug: * Debugger is active!\nINFO:werkzeug: * Debugger PIN: 354-883-950\n</code></pre></p>"}]}