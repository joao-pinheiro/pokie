{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Pokie","text":"<p>--</p> <p> </p> <p>Pokie is a Flask application boilerplate, using Rick and  Rick-db components.</p> <p>Contents: - Pokie Tutorial - Pokie Views - Pokie REST Views</p>"},{"location":"fixtures/","title":"Fixtures","text":"<pre><code>from rick.base import Di\nfrom rick.mixin import Injectable, Runnable\nclass CustomFixture(Injectable, Runnable):\ndef run(self, di:Di):\n# do things here\npass\n</code></pre>"},{"location":"messages/","title":"Messages","text":"<pre><code># get template service\nsvc_template = di.get(DI_SERVICES).get(SVC_MESSAGE_TEMPLATE) # type: MessageTemplateService  \nsvc_queue = di.get(DI_SERVICES).get(SVC_MESSAGE_QUEUE).queue(msg) # type: MessageQueueService\n# get message builder for template 'sample_template', lang='en' and channel SMTP (0)\nbuilder = svc.get_builder('sample_template', 'en', 0)\nif not builder is None:\n# template not found\nraise ValueError(\"invalid email template\")\nmsg = builder.assemble(\n'from@mydomain.local',\n'to@mydomain.local',\n{\n'{name}': 'John Doe'\n})\n# send message to queue\nsvc_queue.queue(msg)\n</code></pre>"},{"location":"signals/","title":"Adding signal handlers","text":"<pre><code>import signal\ndef signal_handler(di, signalnum, stack_trace):\npass\n# get signal manager\nmgr = di.get(DI_SIGNAL) # type: pokie.core.SignalManager\n# register custom handler\nmgr.add_handler(signal.SIGINT, signal_handler())\n</code></pre>"},{"location":"tutorial/architecture/","title":"Pokie Architecture","text":"<p>Pokie promotes both two-tier and three-tier designs with heavy decoupling, in line with both  clean architecture principles and onion architecture principles. The goal is to have only pure object records being carried through the layers, such as RickDB's DTO Objects. Communication is performed strictly top-down: each layer can only interect with the one immediately below,</p> <p>A typical three-tier design has the following layers:</p>"},{"location":"tutorial/architecture/#presentation-layer","title":"Presentation layer","text":"<p>This is the level where Flask views are implemented, using class-based definitions; It is responsible for receiving requests, invoking dependencies, and assembling responses; No specific business-related logic should reside here, adhering to the philosophy of \"thin controllers\".</p> <p>As a default, these classes are instantiated as short-lived objects, and often only exist during the execution of a request, being  destroyed afterwards. As such, all required initialization boilerplate must be as lightweight as possible. </p> <p>To override this behaviour and allow for long-lived view objects, please refer to the Flask documentation.  </p>"},{"location":"tutorial/architecture/#service-layer","title":"Service layer","text":"<p>The service layer provides internal complex functionality to the presentation layer or for internal operation of the application. Services are long-lived (by default atmost one instance created per service), but lazy-loaded - they are only created if invoked for.</p> <p>Services cannot interact with the Presentation layer; they are invoked (via service locator) from the Presentation layer;  the service method signature may or may not be part of a formal interface, depending on design requirements.</p> <p>Services can interact with other services, as well as with the data layer, immediately below. Also, it is quite common to implement caching at the service level.</p> <p>Keep in mind, services are - from a caller's perspective - stateless; they have no context of the application  (eg. if its http or console, what is the current user session, etc), and all operations are - from a caller's perspective - atomic. As such, if cache is implemented, it is up to the internal implementation of the service to ensure cache consistency in such a way the service retains its stateless and context-less properties.</p> <p>Services are invoked by a generic name, via a MapLoader object acting as a service locator. The service classes must inherit the Injectable mixin. </p>"},{"location":"tutorial/architecture/#data-layer","title":"Data layer","text":"<p>The data layer provides basic data operations; this is often achieved by using RickDb's Repository pattern, and DTO classes and objects. Due to the nature of the DTO objects (data-only objects with no business logic or internal state), these can be passed upwards into the presentation layer.</p> <p>Repositories can either be short-lived or long-lived, depending how they are use inside services; the most common approach is to have long-lived repositories defined as properties within the service.</p> <p>The instantiation of a repository is direct, but other mechanisms can be used if a greater degree of decoupling is required.</p>"},{"location":"tutorial/scaffolding/","title":"Application Scaffolding","text":"<p>Pokie applications are organized in modules; these modules reside in folders, and implement specific functionalities, and  have a custom startup script, often called main.py. This script is the main entry point for both web-specific operations and cli-specific operations. Even cli operations will have a full bootstrapped Flask application available.</p> <p>Modules are identified and referenced by name; their name is a string with their full python import path, relative to the main.py script.  The application can use both custom local modules and pre-packaged modules; In fact, a big portion of Pokie's functionality resides itself on a module - pokie.contrib.base.</p> <p>The module structure is identical to a python module, with a few assumptions: - there is always a file named module.py, containing a class called Module, extending BaseModule; - database migrations (if any) are sql files residing in a folder called sql; - modules can provide functionality without requiring web components or interacting with the Flask application; - there is no other requirement regarding module structure besides the optional sql folder and the module.py file; </p>"},{"location":"tutorial/scaffolding/#the-main-module-file-modulepy","title":"The main module file: module.py","text":"<p>This file contains the module initialization class, as well as all the resources made available on the module, including services, cli commands and worker jobs. The class itself must inherit from BaseModule.</p> <p>The module initialization is done in two stages - first, the object instantiation and reading of global attributes, and then, at a later stage, the build() method is called to initialize the module, and register any Flask views that are required for module operation.</p> <p>Keep in mind, as long as the module is initialized, all registered components - services, events, cli commands, worker jobs and migrations are fully working and made available to their respective manager objects.</p> <p>Annotated module.py example: <pre><code>from example.module.constants import SVC_SAMPLE\nfrom pokie.core import BaseModule\nclass Module(BaseModule):\n# internal module name, must be unique\nname = \"module\"\n# internal module description\ndescription = \"Example module\"\n# service map\n#\n# this map registers existing module services, and makes them available to the application. Services are lazy-loaded\n# upon first invocation, to reduce overhead. A service class must inherit the Injectable mixin.\n#\n# The service mapper will load services by service name; As such, service names should be unique, unless the goal\n# is to explicitly override already-registered services\n#\nservices = {\n# service entries are defined as {'service_name': 'path_to_class'}\nSVC_SAMPLE: 'module.service.SampleService',\n}\n# cli command map\n#\n# this map registers existing cli commands exposed by the module. Cli commands are classes that inherit from \n# CliCommand. Cli command names should be unique, unless the goal is to explicitly override existing commands\n#\ncmd = {\n# cli commands are defined as {'command': 'path_to_class'}\n'sample': 'module.cli.SampleCmd'\n}\n# events map\n#\n# Pokie has a concept similar to signals in other framework., but with different capabilities, called Events. Events\n# are classes that extend from EventHandler, and implement a method with the name of the event. Event handler objects\n# are short-lived - they are created upon dispatched of a given event, and de-referenced afterwards.\n#\n# Events have a priority number - handler execution follows the priority number in descending order (lower numbers get\n# executed first)\n# \n# Events also have optional in and out objects, typically used for dictionary composition. A common use case is to add\n# extra information to the response generated on a given information, such as login\n#\n# Event names are unique strings that identify the event; there is no specific requirements for naming, but common\n# convention suggests the usage of snakecase (eg. some_event).\n#\n#\n# events are refined as a two-level structure, containing zero or more events, and then handlers and priorities:\n# events = {\n#   'event_name': {\n#       numeric_priority: [path_to_handler, path_to_handler, ...]\n#   }\n# }\n#\nevents = {\n'my_event_name': {\n10: ['module.event.handler.ExampleEventHandler', ]\n},\n}\n# worker jobs list\n#\n# jobs are tasks that are executed continuously and cooperatively, in a closed loop; their purpose is to execute\n# background operations such as sending emails or resizing images. What makes them different from cron approaches\n# is their continuous execution - there is an idle job with a default 15s pause, and then all other jobs are run\n# sequentially, in a closed loop. If a given job takes too much time to execute, it will delay subsequent jobs, so\n# this approach may not fit all workloads.\n#\n# Jobs are long-lived objects whose class must extend Injectable and Runnable mixins.\n# The job list is a list of strings with the full path for each job class, similar to other existing referencing structures \n#\njobs = [\n# 'full.path.to.job.class'\n]\n# fixture class list\n#\n# fixtures are objects that are run only once; They can be used to load initial/default values or to perform non-trivial\n# database operations, such as data migrations\n#\nfixtures = [\n# 'full.path.to.fixture.class'\n]\ndef build(self, parent=None):\n# This method is called when modules are initialized; At this point, all other dependencies have already been\n# initialized, including the Service Manager, Event Manager and even registered factories\n#\n# All Flask-related routing calls should reside here\npass\n</code></pre></p>"},{"location":"tutorial/scaffolding/#module-directory-structure","title":"Module directory structure","text":"<p>While there are no specific limitations on the module internal structure besides the already mentioned exceptions, a  typical recommended on-disk module layout for a complete module would be as follows: </p> <pre><code>my_project/\n    project_module/     &lt;- module called 'project_module'\n        cli/            &lt;- folder for cli command classes\n            __init__.py\n        dto/            &lt;- folder for DTO's (or RickDb Records)\n            __init__.py                                \n        event/          &lt;- folder for EventHandler classes\n            __init__.py\n        plugin/         &lt;- plugin folder\n            __init__.py                    \n        repository/     &lt;- RickDb Repository classes folder\n            __init__.py\n        service/        &lt;- folder for Service classes\n            __init__.py\n        sql/            &lt;- folder containing SQL migration scripts\n        view/           &lt;- folder for Flask views\n            __init__.py                                                            \n        __init__.py\n        module.py   &lt;- the module initialization class\n\n    other_module/   &lt;- other module\n        ...        \n    main.py         &lt;- the startup script\n</code></pre>"},{"location":"tutorial/tutorial/","title":"Tutorial","text":"<p>`# Pokie Tutorial</p>"},{"location":"tutorial/tutorial/#foreword","title":"Foreword","text":"<p>Pokie is built upon Dependency Injection and Resource Location. As such, dependencies are often specified by a full class path string, instead of a direct import; coupling is inferred in runtime via provided configuration, instead of more traditional approaches of using imports to provide dependencies. One of the main advantages of this approach is the quasi-elimination of circular imports problem, and provides an elegant mechanism of overriding dependencies either at load time or in runtime.</p> <p>Pokie also makes heavy use of classes and namespaces, and often each class will reside in its own file; this requires more discipline when scaffolding an application, and (sometimes) writing classes is more verbose than using more traditional approaches. This is a calculated tradeoff by design, and not just a mere consequence of heavy pattern usage.</p> <p>Contents:</p> <ul> <li>Architecture</li> <li>Scaffolding</li> </ul>"},{"location":"tutorial/tutorial/#initializing-the-application","title":"Initializing the application","text":"<p>To fully bootstrap the application, three components are required: the configuration container (a ShallowContainer instance), the module list to be instantiated, and the factory list to be initialized.</p> <p>It is recommended the bootstrap itself is built inside a factory function with the name build_pokie(); by encapsulating  all the initialization within a single identified function, we can provide a clean application context to run unit  tests.</p> <p>The typical sequence of operations (both explicit and implicit) of a Pokie application is:</p> <ul> <li>load configuration; </li> <li>build base Flask app; </li> <li>load configured modules (instantiate Module objects only);</li> <li>build a service map and initialize the Service Manager;</li> <li>run factories defined in the factory list;</li> <li>parse event definitions from modules and build the Event Manager;</li> <li>initialize modules (by calling build() on each Module object);</li> <li>run appropriate CLI wrapper, or pass app variable to a WSGI server;</li> </ul>"},{"location":"tutorial/tutorial/#configuration","title":"Configuration","text":"<p>Pokie manages configuration using Rick's configuration resources - it supports both environment-variable based configuration or file-based configuration using JSON format. Both are parsed into a ShallowContainer object.</p>"},{"location":"tutorial/tutorial/#environment-based-configuration","title":"Environment-based configuration","text":"<p>Environment-based configuration is a Docker-friendly mechanism to provide configurations; The configuration class extends EnvironmentConfig, and when invoking build(), it attempts to read environment variables matching the existing uppercase-named  class attributes. If a match is found, the default value is replaced. </p> <p>In addition, if the default value is an object of type StrOrFile, it will consider the specified existing value a path to a file containing the actual value. Any StrOrFile attribute with a computed value (either default or injected via environment variables) that starts with / or ./ will be treated as a file to be read to determine the final value. </p> <p>Note: The return ShallowContainer object from build() will have all keys in lowercase, including the ones defined  originally as uppercase. This allows the configuration class to have internal static configuration attributes that are not injectable from environment variables.</p> <p>Minimal Pokie environment-based configuration example:</p> <pre><code>from rick.resource.config import EnvironmentConfig\nfrom pokie.config.template import BaseConfigTemplate\n# minimal Pokie environment-based configuration\n# Pokie's defaults come from BaseConfigTemplate\nclass Config(EnvironmentConfig, BaseConfigTemplate):\npass\n# load configuration and return a ShallowContainer\ncfg = Config().build()\n</code></pre>"},{"location":"tutorial/tutorial/#file-based-configuration","title":"File-based configuration","text":"<p>File-based configuration is comparatively simpler, as all values are read from the specified file. However, default values for settings need also to exist on the file, resulting in more complex files.</p> <p>Minimal Pokie file-based configuration example:</p> <pre><code>from rick.resource.config import json_file\n# load configuration from file and return a ShallowContainer\ncfg = json_file('config.json')\n</code></pre> <p>config.json contents: <pre><code>{\n\"modules\": [],\n\"use_auth\": true,\n\"auth_plugins\": [\"pokie.contrib.auth.plugin.DbAuthPlugin\"],\n\"auth_secret\": \"very_secret_key\",\n\"db_cache_metadata\": false\n}\n</code></pre></p>"},{"location":"tutorial/tutorial/#module-initialization","title":"Module initialization","text":"<p>Bootstrapping a Pokie application requires a list of modules to be initialized; Each element of the list is a string with a python class path for the module itself; Each module directory must then contain a Module class that inherits from BaseModule, inside a file called module.py. This is the initialization class for a given module.</p> <p>The list of modules to be initialized can also be provided via configuration setting, depending on the desired implementation.</p>"},{"location":"tutorial/tutorial/#factory-initialization","title":"Factory initialization","text":"<p>Factories are assorted initializers for several purposes. One of them is to provide lazy loading mechanisms for database connections or cache connections. The factory list is a list of direct classes (python classes, not strings).</p>"},{"location":"tutorial/tutorial/#application-factory-build_pokie","title":"Application factory: build_pokie()","text":"<p>Usage of the main application factory is not mandatory, but essential if unit tests are required. Unit testing often requires the opposite strategy of a production application, in the sense that reusage and caching of objects should be avoided completely. To ensure this, the factory encapsulates the complete bootstrap of the application, in such a way  that can be called once per single test, ensuring that available internal resources are not reused. </p> <p>build_pokie() -&gt; Tuple[FlaskApplication, Flask]  Factory to build a pokie application and returns both the Pokie FlaskApplication object and the Flask object.</p>"},{"location":"tutorial/tutorial/#minimal-mainpy-example","title":"Minimal main.py example","text":"<p>The main.py script is usually a simple file, containing the previously mentioned components. In addition, it should also provide the cli wrapper, to automatically also be able to execute cli operations. To enable this feature, just add this to the bottom of the file:</p> <pre><code>if __name__ == '__main__':\nmain.cli()\n</code></pre> <p>A minimal  but complete main.py example: <pre><code>from rick.resource.config import EnvironmentConfig\nfrom pokie.config.template import BaseConfigTemplate, PgConfigTemplate\nfrom pokie.core import FlaskApplication\nfrom pokie.core.factories.pgsql import PgSqlFactory\n# base configuration\nclass Config(EnvironmentConfig, BaseConfigTemplate, PgConfigTemplate):\npass\ndef build_pokie():\n# load configuration from ENV\ncfg = Config().build()\n# modules to load &amp; initialize:\n# the internal auth module, and a custom-defined local module called 'my_module'\nmodules = ['pokie.contrib.auth', 'my_module']\n# factories to run\n# the postgresql initializer, and the flask-login initializer\nfactories = [PgSqlFactory, FlaskLogin, ]\n# build Pokie application\npokie_app = FlaskApplication(cfg)\n# bootstrap Pokie application\n# the returned object is a Flask application\nflask_app = main.build(modules, factories)\nreturn pokie_app, flask_app\n# main is reused for the cli wrapper\n# app is often reused as the WSGI Flask object \nmain, app = build_pokie()\n# if it is a cli invocation\nif __name__ == '__main__':\n# run the cli wrapper\nmain.cli()\n</code></pre></p> <p>For development purposes, the application can be run directly: <pre><code>$ python3 main.py runserver -d -r\n * Serving Flask app 'FlaskApplication' (lazy loading)\n* Environment: production\n   WARNING: This is a development server. Do not use it in a production deployment.\n   Use a production WSGI server instead.\n * Debug mode: on\nINFO:werkzeug: * Running on http://127.0.0.1:5000 (Press CTRL+C to quit)\nINFO:werkzeug: * Restarting with watchdog (inotify)\nWARNING:werkzeug: * Debugger is active!\nINFO:werkzeug: * Debugger PIN: 354-883-950\n</code></pre></p>"},{"location":"views/","title":"Pokie Views","text":"<p>Pokie extends on the class-based views on Flask, and offers additional features such asautomatic request body unmarshall, custom-named view methods (a-la Controllers), response helpers and authentication.</p> <p>Using Pokie views is not mandatory; however, they are quite handy to implement REST-based APIs, and they provide extra degrees of automation and JSON interaction.</p>"},{"location":"views/#using-pokieview","title":"Using PokieView","text":"<p>PokieView is the base view class of Pokie. This class implements the following functionalities:</p> <ul> <li>optional automatic body deserialization and validation with a RequestRecord class;</li> <li>pre-dispatch hook system;</li> <li>json-first exception handler;</li> <li>json helpers;</li> </ul>"},{"location":"views/#body-deserialization-validation","title":"Body deserialization &amp; validation","text":"<p>The request body can be automatically deserialized and validated for specific http methods (POST, PUT, PATCH) by specifying a RequestRecord class in the request_class class attribute. If the submitted data fails validation, a RequestRecord error response is returned. If validation is successful, the handler method is called and the RequestRecord object instance can be accessed via self.request property.</p> <p>Simple example with a custom RequestRecord class and a POST handler:</p> <pre><code>from rick.form import RequestRecord, field\nfrom pokie.http import PokieView\n# JSON Request validation \nclass FilmRequest(RequestRecord):\nfields = {\n'id': field(validators='id|numeric'),\n'title': field(validators='required'),\n'description': field(validators=''),\n'releaseYear': field(validators='numeric'),\n'rating': field(validators=''),\n'lastUpdate': field(validators='required|iso8601'),\n'sinopse': field(validators='maxlen:2048'),\n}\nclass FilmView(PokieView):\n# use FilmRequest for automatic body deserialization and validation\nrequest_class = FilmRequest\ndef post(self):\nprint(\"submitted data:\")\n#retrieve dict with all submitted values\nprint(self.request.get_data())\n# return a standard JSON success response with code 200:\n# {\"success\":true,\"message\":\"\"}\nreturn self.success() \n</code></pre>"},{"location":"views/#using-custom-dispatch-hooks","title":"Using custom dispatch hooks","text":"<p>Dispatch hooks work as middlweware methods - they can be used to perform additional validations. If a given hook returns a ResponseReturnValue, the dispatch exits with the specified response. If a hook is run successfully, it should return None.</p> <p>Example: <pre><code>from rick.form import RequestRecord, field\nfrom pokie.http import PokieView\n# JSON Request validation \nclass FilmRequest(RequestRecord):\nfields = {\n'id': field(validators='id|numeric'),\n'title': field(validators='required'),\n'description': field(validators=''),\n'releaseYear': field(validators='numeric'),\n'rating': field(validators=''),\n'lastUpdate': field(validators='required|iso8601'),\n'sinopse': field(validators='maxlen:2048'),\n}\nclass FilmView(PokieView):\n# use FilmRequest for automatic body deserialization and validation\nrequest_class = FilmRequest\ndef __init__(self, *args, **kwargs):\nsuper().__init__(*args, **kwargs)\n# add hook method to the hook list\nself.dispatch_hooks.append('_my_hook')\ndef _my_hook(self, method: str, *args: Any, **kwargs: Any) -&gt; Optional[ResponseReturnValue]:\n\"\"\"\n        Custom hook to be executed on dispatch\n        \"\"\"\nif method == 'get':\nreturn self.error('We are blocking GET requests via dispatch hooks')\nreturn None\ndef post(self):\nprint(\"submitted data:\")\n#retrieve dict with all submitted values\nprint(self.request.get_data())\n# return a standard JSON success response with code 200:\n# {\"success\":true,\"message\":\"\"}\nreturn self.success() \n</code></pre></p>"},{"location":"views/rest/","title":"REST Views","text":"<p>Pokie provide several helpers to implement REST endpoints; one of them is the RestMixin mixin. This class extension implements all the basic REST operations for CRUD operations on a given Record/Service. Service can either be the generic pokie.rest.RestService, or a custom service that implements pokie.rest.RestServiceInterface.</p> <p>The RestMixin provides the basic CRUD functionality for a RickDb Record class, effectively allowing automatic creation of CRUD endpoints for database objects, while maintaining a three-tier architectural design.</p> <p>By default, RestMixin will attempt to create a pokie.rest.RestService instance, uniquely named by module and record class. However, if service_name is specified, the associated service will be used instead. Please note that services to be used with the RestMixin class need to extend from pokie.rest.RestServiceMixin.</p> <p>RestMixin example: <pre><code>from pokie.http import PokieView\nfrom pokie.http.rest import RestMixin\nfrom rick.form import RequestRecord, field\nfrom rick_db import fieldmapper\n# DB Record class\n@fieldmapper(tablename='country', pk='country_id', schema='public')\nclass CountryRecord:\nid = 'country_id'\ncountry = 'country'\n# RequestRecord class\nclass CountryRequest(RequestRecord):\nfields = {\n'id': field(validators='id|numeric', bind='id'),\n'country': field(validators='required', bind='country')\n}\n# REST view class\nclass CountryView(PokieView, RestMixin):\n# RequestRecord class for body operations\nrequest_class = CountryRequest\n# Database Record class\nrecord_class = CountryRecord\n# allowed search fields to be used with the search variable\nsearch_fields = [CountryRecord.country]\n# optional custom service name to be used; if no service name is specified, an instance of\n# pokie.rest.RestService is automatically created\n#service_name = 'my-service-name'\n# optional limit for default listing operations\n# if list_limit &gt; 0, the specified value will be used as default limit for unbounded listing requests\n#list_limit = -1    \n</code></pre></p>"},{"location":"views/rest/#registering-routes","title":"Registering routes","text":"<p>RestMixin views can be added to the router using the traditional Flask approach; however, this process often envolves needless creation of similar code. To simplify this process, the pokie.http.route_resource() helper can be used to automate the registration of all endpoints at once:</p> <p><pre><code>from pokie.http import PokieView\nfrom pokie.http.rest import RestMixin\nfrom rick.form import RequestRecord, field\nfrom rick_db import fieldmapper\n# DB Record class\n@fieldmapper(tablename='country', pk='country_id', schema='public')\nclass CountryRecord:\nid = 'country_id'\ncountry = 'country'\n# RequestRecord class\nclass CountryRequest(RequestRecord):\nfields = {\n'id': field(validators='id|numeric', bind='id'),\n'country': field(validators='required', bind='country')\n}\n# REST view class\nclass CountryView(PokieView, RestMixin):\npass\n(...)\n# register all routes automatically\nroute_resource(app, 'country', CountryView)\n</code></pre> The following routes will be registered:</p> Url Method Description /country GET List records /country POST Create record /country/:id GET Get record by id /country/:id PUT Update record /country/:id DELETE Delete record"},{"location":"views/rest/#using-restmixin-grid-capabilities","title":"Using RestMixin grid capabilities","text":"<p>By leveraging DbGrid capabilities, the RestMixin offers a set of relevant features for advanced scenarios, such as server-side pagination, sorting and search.</p> <p>the following url variables are available:</p> Variable Format Example Description - - /url List all records, see response type below offset /url?offset=5 List records starting at specified zero-based offset limit /url?limit=5 List limit amount of records search /url?search=foo List search results for search expression match field:value|other_field:other_value[...|field...] /url?match=age:22|gender:M List records with exact match on the set of conditions presented sort field:asc,field:desc /url?sort=name:asc,age:desc Sort records by specified conditions"},{"location":"views/rest/#using-offset-limit","title":"Using offset, limit","text":"<p>Offset and limit behave like their SQL counterparts - zero-based integer numbers specifying an absolute value. They can be combined to perform pagination:</p> <pre><code># pagination with 10 records per page\n/url?offset=10&amp;limit=10\n</code></pre>"},{"location":"views/rest/#using-search","title":"Using search","text":"<p>Search is performed in all fields specified in the view class search_fields attribute. The search is performed as  case-insensitive %expression%, allowing for matches inside strings. If multiple fields are specified in search_fields, the search is performed with OR concatenation - the result record list is the combination of all individual matches on each  field. Some of the internals of the search behaviour can be overridden by providing a custom Service class that extends the pokie.rest.RestServiceMixin mixin and overrides the list() method implementation.</p>"},{"location":"views/rest/#using-sort","title":"Using sort","text":"<p>Sort can be performed on multiple fields at once, and sort order can either be 'asc' or 'desc' in case-insensitive form.</p>"},{"location":"views/rest/#default-operation-and-mixing-multiple-options","title":"Default operation and mixing multiple options","text":"<p>By default, a naked GET request to the listing endpoint will return all records; However, this may not be desirable when the dataset size is bigger than a few hundred rows. It is possible to cap the default listing to a given number of rows by changing the list_limit class attribute.</p> <p>All or part of the specified options can be combined in a single request, to perform a server-side sorting &amp; filtering procedure.</p> <p>Querying an endpoint with curl, using offset, limit, search and sort on the records: <pre><code>$ curl -X GET -H 'Content-Type: application/json' http://127.0.0.1:5000/my_url?offset=10&amp;limit=10&amp;search=john&amp;sort=name:desc\n</code></pre></p>"},{"location":"views/rest/#response-format","title":"Response format","text":"<p>All RestMixin operations return a variable JSON dataset with the following structure:</p> <p><pre><code>{\n\"total\": 110,\n\"rows\": [\n...list\nof\nrecord\nobjects...\n]\n}\n</code></pre> Where total is the total amount of rows on the source dataset, ignoring offset and limit constraints, allowing the implementation of server-side pagination.</p>"}]}