{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Pokie Pokie is a Flask application boilerplate, built on top of Rick and Rick-db components. Contents: - Pokie Tutorial - Pokie Views - Pokie REST Views","title":"Overview"},{"location":"#welcome-to-pokie","text":"Pokie is a Flask application boilerplate, built on top of Rick and Rick-db components. Contents: - Pokie Tutorial - Pokie Views - Pokie REST Views","title":"Welcome to Pokie"},{"location":"tutorial/architecture/","text":"Pokie Architecture Pokie promotes both two-tier and three-tier designs with heavy decoupling, in line with both clean architecture principles and onion architecture principles. The goal is to have only pure object records being carried through the layers, such as RickDB's DTO Objects . Communication is performed strictly top-down: each layer can only interect with the one immediately below, A typical three-tier design has the following layers: Presentation layer This is the level where Flask views are implemented, using class-based definitions; It is responsible for receiving requests, invoking dependencies, and assembling responses; No specific business-related logic should reside here, adhering to the philosophy of \"thin controllers\". As a default, these classes are instantiated as short-lived objects, and often only exist during the execution of a request, being destroyed afterwards. As such, all required initialization boilerplate must be as lightweight as possible. To override this behaviour and allow for long-lived view objects, please refer to the Flask documentation. Service layer The service layer provides internal complex functionality to the presentation layer or for internal operation of the application. Services are long-lived (by default atmost one instance created per service), but lazy-loaded - they are only created if invoked for. Services cannot interact with the Presentation layer; they are invoked (via service locator) from the Presentation layer; the service method signature may or may not be part of a formal interface, depending on design requirements. Services can interact with other services, as well as with the data layer, immediately below. Also, it is quite common to implement caching at the service level. Keep in mind, services are - from a caller's perspective - stateless; they have no context of the application (eg. if its http or console, what is the current user session, etc), and all operations are - from a caller's perspective - atomic. As such, if cache is implemented, it is up to the internal implementation of the service to ensure cache consistency in such a way the service retains its stateless and context-less properties. Services are invoked by a generic name, via a MapLoader object acting as a service locator. The service classes must inherit the Injectable mixin. Data layer The data layer provides basic data operations; this is often achieved by using RickDb's Repository pattern, and DTO classes and objects. Due to the nature of the DTO objects (data-only objects with no business logic or internal state), these can be passed upwards into the presentation layer. Repositories can either be short-lived or long-lived, depending how they are use inside services; the most common approach is to have long-lived repositories defined as properties within the service. The instantiation of a repository is direct, but other mechanisms can be used if a greater degree of decoupling is required.","title":"Architecture"},{"location":"tutorial/architecture/#pokie-architecture","text":"Pokie promotes both two-tier and three-tier designs with heavy decoupling, in line with both clean architecture principles and onion architecture principles. The goal is to have only pure object records being carried through the layers, such as RickDB's DTO Objects . Communication is performed strictly top-down: each layer can only interect with the one immediately below, A typical three-tier design has the following layers:","title":"Pokie Architecture"},{"location":"tutorial/architecture/#presentation-layer","text":"This is the level where Flask views are implemented, using class-based definitions; It is responsible for receiving requests, invoking dependencies, and assembling responses; No specific business-related logic should reside here, adhering to the philosophy of \"thin controllers\". As a default, these classes are instantiated as short-lived objects, and often only exist during the execution of a request, being destroyed afterwards. As such, all required initialization boilerplate must be as lightweight as possible. To override this behaviour and allow for long-lived view objects, please refer to the Flask documentation.","title":"Presentation layer"},{"location":"tutorial/architecture/#service-layer","text":"The service layer provides internal complex functionality to the presentation layer or for internal operation of the application. Services are long-lived (by default atmost one instance created per service), but lazy-loaded - they are only created if invoked for. Services cannot interact with the Presentation layer; they are invoked (via service locator) from the Presentation layer; the service method signature may or may not be part of a formal interface, depending on design requirements. Services can interact with other services, as well as with the data layer, immediately below. Also, it is quite common to implement caching at the service level. Keep in mind, services are - from a caller's perspective - stateless; they have no context of the application (eg. if its http or console, what is the current user session, etc), and all operations are - from a caller's perspective - atomic. As such, if cache is implemented, it is up to the internal implementation of the service to ensure cache consistency in such a way the service retains its stateless and context-less properties. Services are invoked by a generic name, via a MapLoader object acting as a service locator. The service classes must inherit the Injectable mixin.","title":"Service layer"},{"location":"tutorial/architecture/#data-layer","text":"The data layer provides basic data operations; this is often achieved by using RickDb's Repository pattern, and DTO classes and objects. Due to the nature of the DTO objects (data-only objects with no business logic or internal state), these can be passed upwards into the presentation layer. Repositories can either be short-lived or long-lived, depending how they are use inside services; the most common approach is to have long-lived repositories defined as properties within the service. The instantiation of a repository is direct, but other mechanisms can be used if a greater degree of decoupling is required.","title":"Data layer"},{"location":"tutorial/scaffolding/","text":"Application Scaffolding Pokie applications are organized in modules; these modules reside in folders, and implement specific functionalities, and have a custom startup script, often called main.py. This script is the main entry point for both web-specific operations and cli-specific operations. Even cli operations will have a full bootstrapped Flask application available. Modules are identified and referenced by name; their name is a string with their full python import path, relative to the main.py script. The application can use both custom local modules and pre-packaged modules; In fact, a big portion of Pokie's functionality resides itself on a module - pokie.contrib.base. The module structure is identical to a python module, with a few assumptions: - there is always a file named module.py , containing a class called Module , extending BaseModule ; - database migrations (if any) are sql files residing in a folder called sql ; - modules can provide functionality without requiring web components or interacting with the Flask application; - there is no other requirement regarding module structure besides the optional sql folder and the module.py file; The main module file: module.py This file contains the module initialization class, as well as all the resources made available on the module, including services, cli commands and worker jobs. The class itself must inherit from BaseModule . The module initialization is done in two stages - first, the object instantiation and reading of global attributes, and then, at a later stage, the build() method is called to initialize the module, and register any Flask views that are required for module operation. Keep in mind, as long as the module is initialized, all registered components - services, events, cli commands, worker jobs and migrations are fully working and made available to their respective manager objects. Annotated module.py example: from example.module.constants import SVC_SAMPLE from pokie.core import BaseModule class Module ( BaseModule ): # internal module name, must be unique name = \"module\" # internal module description description = \"Example module\" # service map # # this map registers existing module services, and makes them available to the application. Services are lazy-loaded # upon first invocation, to reduce overhead. A service class must inherit the Injectable mixin. # # The service mapper will load services by service name; As such, service names should be unique, unless the goal # is to explicitly override already-registered services # services = { # service entries are defined as {'service_name': 'path_to_class'} SVC_SAMPLE : 'module.service.SampleService' , } # cli command map # # this map registers existing cli commands exposed by the module. Cli commands are classes that inherit from # CliCommand. Cli command names should be unique, unless the goal is to explicitly override existing commands # cmd = { # cli commands are defined as {'command': 'path_to_class'} 'sample' : 'module.cli.SampleCmd' } # events map # # Pokie has a concept similar to signals in other framework., but with different capabilities, called Events. Events # are classes that extend from EventHandler, and implement a method with the name of the event. Event handler objects # are short-lived - they are created upon dispatched of a given event, and de-referenced afterwards. # # Events have a priority number - handler execution follows the priority number in descending order (lower numbers get # executed first) # # Events also have optional in and out objects, typically used for dictionary composition. A common use case is to add # extra information to the response generated on a given information, such as login # # Event names are unique strings that identify the event; there is no specific requirements for naming, but common # convention suggests the usage of snakecase (eg. some_event). # # # events are refined as a two-level structure, containing zero or more events, and then handlers and priorities: # events = { # 'event_name': { # numeric_priority: [path_to_handler, path_to_handler, ...] # } # } # events = { 'my_event_name' : { 10 : [ 'module.event.handler.ExampleEventHandler' , ] }, } # worker jobs list # # jobs are tasks that are executed continuously and cooperatively, in a closed loop; their purpose is to execute # background operations such as sending emails or resizing images. What makes them different from cron approaches # is their continuous execution - there is an idle job with a default 15s pause, and then all other jobs are run # sequentially, in a closed loop. If a given job takes too much time to execute, it will delay subsequent jobs, so # this approach may not fit all workloads. # # Jobs are long-lived objects whose class must extend Injectable and Runnable mixins. # The job list is a list of strings with the full path for each job class, similar to other existing referencing structures # jobs = [ # 'full.path.to.job.class' ] def build ( self , parent = None ): # This method is called when modules are initialized; At this point, all other dependencies have already been # initialized, including the Service Manager, Event Manager and even registered factories # # All Flask-related routing calls should reside here pass Module directory structure While there are no specific limitations on the module internal structure besides the already mentioned exceptions, a typical recommended on-disk module layout for a complete module would be as follows: my_project/ project_module/ <- module called 'project_module' cli/ <- folder for cli command classes __init__.py dto/ <- folder for DTO's (or RickDb Records) __init__.py event/ <- folder for EventHandler classes __init__.py plugin/ <- plugin folder __init__.py repository/ <- RickDb Repository classes folder __init__.py service/ <- folder for Service classes __init__.py sql/ <- folder containing SQL migration scripts view/ <- folder for Flask views __init__.py __init__.py module.py <- the module initialization class other_module/ <- other module ... main.py <- the startup script","title":"Scaffolding"},{"location":"tutorial/scaffolding/#application-scaffolding","text":"Pokie applications are organized in modules; these modules reside in folders, and implement specific functionalities, and have a custom startup script, often called main.py. This script is the main entry point for both web-specific operations and cli-specific operations. Even cli operations will have a full bootstrapped Flask application available. Modules are identified and referenced by name; their name is a string with their full python import path, relative to the main.py script. The application can use both custom local modules and pre-packaged modules; In fact, a big portion of Pokie's functionality resides itself on a module - pokie.contrib.base. The module structure is identical to a python module, with a few assumptions: - there is always a file named module.py , containing a class called Module , extending BaseModule ; - database migrations (if any) are sql files residing in a folder called sql ; - modules can provide functionality without requiring web components or interacting with the Flask application; - there is no other requirement regarding module structure besides the optional sql folder and the module.py file;","title":"Application Scaffolding"},{"location":"tutorial/scaffolding/#the-main-module-file-modulepy","text":"This file contains the module initialization class, as well as all the resources made available on the module, including services, cli commands and worker jobs. The class itself must inherit from BaseModule . The module initialization is done in two stages - first, the object instantiation and reading of global attributes, and then, at a later stage, the build() method is called to initialize the module, and register any Flask views that are required for module operation. Keep in mind, as long as the module is initialized, all registered components - services, events, cli commands, worker jobs and migrations are fully working and made available to their respective manager objects. Annotated module.py example: from example.module.constants import SVC_SAMPLE from pokie.core import BaseModule class Module ( BaseModule ): # internal module name, must be unique name = \"module\" # internal module description description = \"Example module\" # service map # # this map registers existing module services, and makes them available to the application. Services are lazy-loaded # upon first invocation, to reduce overhead. A service class must inherit the Injectable mixin. # # The service mapper will load services by service name; As such, service names should be unique, unless the goal # is to explicitly override already-registered services # services = { # service entries are defined as {'service_name': 'path_to_class'} SVC_SAMPLE : 'module.service.SampleService' , } # cli command map # # this map registers existing cli commands exposed by the module. Cli commands are classes that inherit from # CliCommand. Cli command names should be unique, unless the goal is to explicitly override existing commands # cmd = { # cli commands are defined as {'command': 'path_to_class'} 'sample' : 'module.cli.SampleCmd' } # events map # # Pokie has a concept similar to signals in other framework., but with different capabilities, called Events. Events # are classes that extend from EventHandler, and implement a method with the name of the event. Event handler objects # are short-lived - they are created upon dispatched of a given event, and de-referenced afterwards. # # Events have a priority number - handler execution follows the priority number in descending order (lower numbers get # executed first) # # Events also have optional in and out objects, typically used for dictionary composition. A common use case is to add # extra information to the response generated on a given information, such as login # # Event names are unique strings that identify the event; there is no specific requirements for naming, but common # convention suggests the usage of snakecase (eg. some_event). # # # events are refined as a two-level structure, containing zero or more events, and then handlers and priorities: # events = { # 'event_name': { # numeric_priority: [path_to_handler, path_to_handler, ...] # } # } # events = { 'my_event_name' : { 10 : [ 'module.event.handler.ExampleEventHandler' , ] }, } # worker jobs list # # jobs are tasks that are executed continuously and cooperatively, in a closed loop; their purpose is to execute # background operations such as sending emails or resizing images. What makes them different from cron approaches # is their continuous execution - there is an idle job with a default 15s pause, and then all other jobs are run # sequentially, in a closed loop. If a given job takes too much time to execute, it will delay subsequent jobs, so # this approach may not fit all workloads. # # Jobs are long-lived objects whose class must extend Injectable and Runnable mixins. # The job list is a list of strings with the full path for each job class, similar to other existing referencing structures # jobs = [ # 'full.path.to.job.class' ] def build ( self , parent = None ): # This method is called when modules are initialized; At this point, all other dependencies have already been # initialized, including the Service Manager, Event Manager and even registered factories # # All Flask-related routing calls should reside here pass","title":"The main module file: module.py"},{"location":"tutorial/scaffolding/#module-directory-structure","text":"While there are no specific limitations on the module internal structure besides the already mentioned exceptions, a typical recommended on-disk module layout for a complete module would be as follows: my_project/ project_module/ <- module called 'project_module' cli/ <- folder for cli command classes __init__.py dto/ <- folder for DTO's (or RickDb Records) __init__.py event/ <- folder for EventHandler classes __init__.py plugin/ <- plugin folder __init__.py repository/ <- RickDb Repository classes folder __init__.py service/ <- folder for Service classes __init__.py sql/ <- folder containing SQL migration scripts view/ <- folder for Flask views __init__.py __init__.py module.py <- the module initialization class other_module/ <- other module ... main.py <- the startup script","title":"Module directory structure"},{"location":"tutorial/tutorial/","text":"Pokie Tutorial Foreword Pokie is built upon Dependency Injection and Resource Location. As such, dependencies are often specified by a full class path string, instead of a direct import; coupling is inferred in runtime via provided configuration, instead of more traditional approaches of using imports to provide dependencies. One of the main advantages of this approach is the quasi-elimination of circular imports problem, and provides an elegant mechanism of overriding dependencies either at load time or in runtime. Pokie also makes heavy use of classes and namespaces, and often each class will reside in its own file; this requires more discipline when scaffolding an application, and (sometimes) writing classes is more verbose than using more traditional approaches. This is a calculated tradeoff by design, and not just a mere consequence of heavy pattern usage. Contents : Architecture Scaffolding Initializing the application To fully bootstrap the application, three components are required: the configuration container (a ShallowContainer instance), the module list to be instantiated, and the factory list to be initialized. The typical sequence of operations (both explicit and implicit) of a Pokie application is: load configuration; build base Flask app; load configured modules (instantiate Module objects only); build a service map and initialize the Service Manager; run factories defined in the factory list; parse event definitions from modules and build the Event Manager; initialize modules (by calling build() on each Module object); run appropriate CLI wrapper, or pass app variable to a WSGI server; Configuration Pokie manages configuration using Rick's configuration resources - it supports both environment-variable based configuration or file-based configuration using JSON format. Both are parsed into a ShallowContainer object. Environment-based configuration Environment-based configuration is a Docker-friendly mechanism to provide configurations; The configuration class extends EnvironmentConfig , and when invoking build(), it attempts to read environment variables matching the existing uppercase-named class attributes . If a match is found, the default value is replaced. In addition, if the default value is an object of type StrOrFile , it will consider the specified existing value a path to a file containing the actual value. Any StrOrFile attribute with a computed value (either default or injected via environment variables) that starts with / or ./ will be treated as a file to be read to determine the final value. Note: The return ShallowContainer object from build() will have all keys in lowercase , including the ones defined originally as uppercase. This allows the configuration class to have internal static configuration attributes that are not injectable from environment variables. Minimal Pokie environment-based configuration example: from rick.resource.config import EnvironmentConfig from pokie.config.template import BaseConfigTemplate # minimal Pokie environment-based configuration # Pokie's defaults come from BaseConfigTemplate class Config ( EnvironmentConfig , BaseConfigTemplate ): pass # load configuration and return a ShallowContainer cfg = Config () . build () File-based configuration File-based configuration is comparatively simpler, as all values are read from the specified file. However, default values for settings need also to exist on the file, resulting in more complex files. Minimal Pokie file-based configuration example: from rick.resource.config import json_file # load configuration from file and return a ShallowContainer cfg = json_file ( 'config.json' ) config.json contents: { \"modules\" : [], \"use_auth\" : true , \"auth_plugins\" : [ \"pokie.contrib.auth.plugin.DbAuthPlugin\" ], \"auth_secret\" : \"very_secret_key\" , \"db_cache_metadata\" : false } Module initialization Bootstrapping a Pokie application requires a list of modules to be initialized; Each element of the list is a string with a python class path for the module itself; Each module directory must then contain a Module class that inherits from BaseModule , inside a file called module.py . This is the initialization class for a given module. The list of modules to be initialized can also be provided via configuration setting, depending on the desired implementation. Factory initialization Factories are assorted initializers for several purposes. One of them is to provide lazy loading mechanisms for database connections or cache connections. The factory list is a list of direct classes (python classes, not strings). Minimal main.py example The main.py script is usually a simple file, containing the previously mentioned components. In addition, it should also provide the cli wrapper, to automatically also be able to execute cli operations. To enable this feature, just add this to the bottom of the file: if __name__ == '__main__' : main . cli () A minimal but complete main.py example: from rick.resource.config import EnvironmentConfig from pokie.config.template import BaseConfigTemplate , PgConfigTemplate from pokie.core import FlaskApplication from pokie.core.factories.pgsql import PgSqlFactory # base configuration class Config ( EnvironmentConfig , BaseConfigTemplate , PgConfigTemplate ): pass # load configuration from ENV cfg = Config () . build () # modules to load & initialize: # the internal auth module, and a custom-defined local module called 'my_module' modules = [ 'pokie.contrib.auth' , 'my_module' ] # factories to run # the postgresql initializer, and the flask-login initializer factories = [ PgSqlFactory , FlaskLogin , ] # build Pokie application main = FlaskApplication ( cfg ) # bootstrap Pokie application # the returned object is a Flask application app = main . build ( modules , factories ) # if it is a cli invocation if __name__ == '__main__' : # run the cli wrapper main . cli () For development purposes, the application can be run directly: $ python3 main.py runserver -d -r * Serving Flask app 'FlaskApplication' ( lazy loading ) * Environment: production WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. * Debug mode: on INFO:werkzeug: * Running on http://127.0.0.1:5000 ( Press CTRL+C to quit ) INFO:werkzeug: * Restarting with watchdog ( inotify ) WARNING:werkzeug: * Debugger is active! INFO:werkzeug: * Debugger PIN: 354 -883-950","title":"Tutorial"},{"location":"tutorial/tutorial/#pokie-tutorial","text":"","title":"Pokie Tutorial"},{"location":"tutorial/tutorial/#foreword","text":"Pokie is built upon Dependency Injection and Resource Location. As such, dependencies are often specified by a full class path string, instead of a direct import; coupling is inferred in runtime via provided configuration, instead of more traditional approaches of using imports to provide dependencies. One of the main advantages of this approach is the quasi-elimination of circular imports problem, and provides an elegant mechanism of overriding dependencies either at load time or in runtime. Pokie also makes heavy use of classes and namespaces, and often each class will reside in its own file; this requires more discipline when scaffolding an application, and (sometimes) writing classes is more verbose than using more traditional approaches. This is a calculated tradeoff by design, and not just a mere consequence of heavy pattern usage. Contents : Architecture Scaffolding","title":"Foreword"},{"location":"tutorial/tutorial/#initializing-the-application","text":"To fully bootstrap the application, three components are required: the configuration container (a ShallowContainer instance), the module list to be instantiated, and the factory list to be initialized. The typical sequence of operations (both explicit and implicit) of a Pokie application is: load configuration; build base Flask app; load configured modules (instantiate Module objects only); build a service map and initialize the Service Manager; run factories defined in the factory list; parse event definitions from modules and build the Event Manager; initialize modules (by calling build() on each Module object); run appropriate CLI wrapper, or pass app variable to a WSGI server;","title":"Initializing the application"},{"location":"tutorial/tutorial/#configuration","text":"Pokie manages configuration using Rick's configuration resources - it supports both environment-variable based configuration or file-based configuration using JSON format. Both are parsed into a ShallowContainer object.","title":"Configuration"},{"location":"tutorial/tutorial/#environment-based-configuration","text":"Environment-based configuration is a Docker-friendly mechanism to provide configurations; The configuration class extends EnvironmentConfig , and when invoking build(), it attempts to read environment variables matching the existing uppercase-named class attributes . If a match is found, the default value is replaced. In addition, if the default value is an object of type StrOrFile , it will consider the specified existing value a path to a file containing the actual value. Any StrOrFile attribute with a computed value (either default or injected via environment variables) that starts with / or ./ will be treated as a file to be read to determine the final value. Note: The return ShallowContainer object from build() will have all keys in lowercase , including the ones defined originally as uppercase. This allows the configuration class to have internal static configuration attributes that are not injectable from environment variables. Minimal Pokie environment-based configuration example: from rick.resource.config import EnvironmentConfig from pokie.config.template import BaseConfigTemplate # minimal Pokie environment-based configuration # Pokie's defaults come from BaseConfigTemplate class Config ( EnvironmentConfig , BaseConfigTemplate ): pass # load configuration and return a ShallowContainer cfg = Config () . build ()","title":"Environment-based configuration"},{"location":"tutorial/tutorial/#file-based-configuration","text":"File-based configuration is comparatively simpler, as all values are read from the specified file. However, default values for settings need also to exist on the file, resulting in more complex files. Minimal Pokie file-based configuration example: from rick.resource.config import json_file # load configuration from file and return a ShallowContainer cfg = json_file ( 'config.json' ) config.json contents: { \"modules\" : [], \"use_auth\" : true , \"auth_plugins\" : [ \"pokie.contrib.auth.plugin.DbAuthPlugin\" ], \"auth_secret\" : \"very_secret_key\" , \"db_cache_metadata\" : false }","title":"File-based configuration"},{"location":"tutorial/tutorial/#module-initialization","text":"Bootstrapping a Pokie application requires a list of modules to be initialized; Each element of the list is a string with a python class path for the module itself; Each module directory must then contain a Module class that inherits from BaseModule , inside a file called module.py . This is the initialization class for a given module. The list of modules to be initialized can also be provided via configuration setting, depending on the desired implementation.","title":"Module initialization"},{"location":"tutorial/tutorial/#factory-initialization","text":"Factories are assorted initializers for several purposes. One of them is to provide lazy loading mechanisms for database connections or cache connections. The factory list is a list of direct classes (python classes, not strings).","title":"Factory initialization"},{"location":"tutorial/tutorial/#minimal-mainpy-example","text":"The main.py script is usually a simple file, containing the previously mentioned components. In addition, it should also provide the cli wrapper, to automatically also be able to execute cli operations. To enable this feature, just add this to the bottom of the file: if __name__ == '__main__' : main . cli () A minimal but complete main.py example: from rick.resource.config import EnvironmentConfig from pokie.config.template import BaseConfigTemplate , PgConfigTemplate from pokie.core import FlaskApplication from pokie.core.factories.pgsql import PgSqlFactory # base configuration class Config ( EnvironmentConfig , BaseConfigTemplate , PgConfigTemplate ): pass # load configuration from ENV cfg = Config () . build () # modules to load & initialize: # the internal auth module, and a custom-defined local module called 'my_module' modules = [ 'pokie.contrib.auth' , 'my_module' ] # factories to run # the postgresql initializer, and the flask-login initializer factories = [ PgSqlFactory , FlaskLogin , ] # build Pokie application main = FlaskApplication ( cfg ) # bootstrap Pokie application # the returned object is a Flask application app = main . build ( modules , factories ) # if it is a cli invocation if __name__ == '__main__' : # run the cli wrapper main . cli () For development purposes, the application can be run directly: $ python3 main.py runserver -d -r * Serving Flask app 'FlaskApplication' ( lazy loading ) * Environment: production WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. * Debug mode: on INFO:werkzeug: * Running on http://127.0.0.1:5000 ( Press CTRL+C to quit ) INFO:werkzeug: * Restarting with watchdog ( inotify ) WARNING:werkzeug: * Debugger is active! INFO:werkzeug: * Debugger PIN: 354 -883-950","title":"Minimal main.py example"},{"location":"views/","text":"Pokie Views Pokie extends on the class-based views on Flask, and offers additional features such asautomatic request body unmarshall, custom-named view methods (a-la Controllers), response helpers and authentication. Using Pokie views is not mandatory; however, they are quite handy to implement REST-based APIs, and they provide extra degrees of automation and JSON interaction. Using PokieView PokieView is the base view class of Pokie. This class implements the following functionalities: optional automatic body deserialization and validation with a RequestRecord class; pre-dispatch hook system; json-first exception handler; json helpers; Body deserialization & validation The request body can be automatically deserialized and validated for specific http methods (POST, PUT, PATCH) by specifying a RequestRecord class in the request_class class attribute. If the submitted data fails validation, a RequestRecord error response is returned. If validation is successful, the handler method is called and the RequestRecord object instance can be accessed via self.request property. Simple example with a custom RequestRecord class and a POST handler: from rick.form import RequestRecord , field from pokie.http import PokieView # JSON Request validation class FilmRequest ( RequestRecord ): fields = { 'id' : field ( validators = 'id|numeric' ), 'title' : field ( validators = 'required' ), 'description' : field ( validators = '' ), 'releaseYear' : field ( validators = 'numeric' ), 'rating' : field ( validators = '' ), 'lastUpdate' : field ( validators = 'required|iso8601' ), 'sinopse' : field ( validators = 'maxlen:2048' ), } class FilmView ( PokieView ): # use FilmRequest for automatic body deserialization and validation request_class = FilmRequest def post ( self ): print ( \"submitted data:\" ) #retrieve dict with all submitted values print ( self . request . get_data ()) # return a standard JSON success response with code 200: # {\"success\":true,\"message\":\"\"} return self . success () Using custom dispatch hooks Dispatch hooks work as middlweware methods - they can be used to perform additional validations. If a given hook returns a ResponseReturnValue , the dispatch exits with the specified response. If a hook is run successfully, it should return None. Example: from rick.form import RequestRecord , field from pokie.http import PokieView # JSON Request validation class FilmRequest ( RequestRecord ): fields = { 'id' : field ( validators = 'id|numeric' ), 'title' : field ( validators = 'required' ), 'description' : field ( validators = '' ), 'releaseYear' : field ( validators = 'numeric' ), 'rating' : field ( validators = '' ), 'lastUpdate' : field ( validators = 'required|iso8601' ), 'sinopse' : field ( validators = 'maxlen:2048' ), } class FilmView ( PokieView ): # use FilmRequest for automatic body deserialization and validation request_class = FilmRequest def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) # add hook method to the hook list self . dispatch_hooks . append ( '_my_hook' ) def _my_hook ( self , method : str , * args : Any , ** kwargs : Any ) -> Optional [ ResponseReturnValue ]: \"\"\" Custom hook to be executed on dispatch \"\"\" if method == 'get' : return self . error ( 'We are blocking GET requests via dispatch hooks' ) return None def post ( self ): print ( \"submitted data:\" ) #retrieve dict with all submitted values print ( self . request . get_data ()) # return a standard JSON success response with code 200: # {\"success\":true,\"message\":\"\"} return self . success ()","title":"Pokie Views"},{"location":"views/#pokie-views","text":"Pokie extends on the class-based views on Flask, and offers additional features such asautomatic request body unmarshall, custom-named view methods (a-la Controllers), response helpers and authentication. Using Pokie views is not mandatory; however, they are quite handy to implement REST-based APIs, and they provide extra degrees of automation and JSON interaction.","title":"Pokie Views"},{"location":"views/#using-pokieview","text":"PokieView is the base view class of Pokie. This class implements the following functionalities: optional automatic body deserialization and validation with a RequestRecord class; pre-dispatch hook system; json-first exception handler; json helpers;","title":"Using PokieView"},{"location":"views/#body-deserialization-validation","text":"The request body can be automatically deserialized and validated for specific http methods (POST, PUT, PATCH) by specifying a RequestRecord class in the request_class class attribute. If the submitted data fails validation, a RequestRecord error response is returned. If validation is successful, the handler method is called and the RequestRecord object instance can be accessed via self.request property. Simple example with a custom RequestRecord class and a POST handler: from rick.form import RequestRecord , field from pokie.http import PokieView # JSON Request validation class FilmRequest ( RequestRecord ): fields = { 'id' : field ( validators = 'id|numeric' ), 'title' : field ( validators = 'required' ), 'description' : field ( validators = '' ), 'releaseYear' : field ( validators = 'numeric' ), 'rating' : field ( validators = '' ), 'lastUpdate' : field ( validators = 'required|iso8601' ), 'sinopse' : field ( validators = 'maxlen:2048' ), } class FilmView ( PokieView ): # use FilmRequest for automatic body deserialization and validation request_class = FilmRequest def post ( self ): print ( \"submitted data:\" ) #retrieve dict with all submitted values print ( self . request . get_data ()) # return a standard JSON success response with code 200: # {\"success\":true,\"message\":\"\"} return self . success ()","title":"Body deserialization &amp; validation"},{"location":"views/#using-custom-dispatch-hooks","text":"Dispatch hooks work as middlweware methods - they can be used to perform additional validations. If a given hook returns a ResponseReturnValue , the dispatch exits with the specified response. If a hook is run successfully, it should return None. Example: from rick.form import RequestRecord , field from pokie.http import PokieView # JSON Request validation class FilmRequest ( RequestRecord ): fields = { 'id' : field ( validators = 'id|numeric' ), 'title' : field ( validators = 'required' ), 'description' : field ( validators = '' ), 'releaseYear' : field ( validators = 'numeric' ), 'rating' : field ( validators = '' ), 'lastUpdate' : field ( validators = 'required|iso8601' ), 'sinopse' : field ( validators = 'maxlen:2048' ), } class FilmView ( PokieView ): # use FilmRequest for automatic body deserialization and validation request_class = FilmRequest def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) # add hook method to the hook list self . dispatch_hooks . append ( '_my_hook' ) def _my_hook ( self , method : str , * args : Any , ** kwargs : Any ) -> Optional [ ResponseReturnValue ]: \"\"\" Custom hook to be executed on dispatch \"\"\" if method == 'get' : return self . error ( 'We are blocking GET requests via dispatch hooks' ) return None def post ( self ): print ( \"submitted data:\" ) #retrieve dict with all submitted values print ( self . request . get_data ()) # return a standard JSON success response with code 200: # {\"success\":true,\"message\":\"\"} return self . success ()","title":"Using custom dispatch hooks"},{"location":"views/controllers/","text":"","title":"Controllers"},{"location":"views/named/","text":"","title":"Named"},{"location":"views/rest/","text":"REST Views Pokie provide several helpers to implement REST endpoints; one of them is the RestMixin mixin. This class extension implements all the basic REST operations for CRUD operations on a given Record/Service. Service can either be the generic pokie.rest.RestService , or a custom service that implements pokie.rest.RestServiceInterface . The RestMixin provides the basic CRUD functionality for a RickDb Record class, effectively allowing automatic creation of CRUD endpoints for database objects, while maintaining a three-tier architectural design. By default, RestMixin will attempt to create a pokie.rest.RestService instance, uniquely named by module and record class. However, if service_name is specified, the associated service will be used instead. Please note that services to be used with the RestMixin class need to extend from pokie.rest.RestServiceMixin . RestMixin example: from pokie.http import PokieView from pokie.http.rest import RestMixin from rick.form import RequestRecord , field from rick_db import fieldmapper # DB Record class @fieldmapper ( tablename = 'country' , pk = 'country_id' , schema = 'public' ) class CountryRecord : id = 'country_id' country = 'country' # RequestRecord class class CountryRequest ( RequestRecord ): fields = { 'id' : field ( validators = 'id|numeric' , bind = 'id' ), 'country' : field ( validators = 'required' , bind = 'country' ) } # REST view class class CountryView ( PokieView , RestMixin ): # RequestRecord class for body operations request_class = CountryRequest # Database Record class record_class = CountryRecord # allowed search fields to be used with the search variable search_fields = [ CountryRecord . country ] # optional custom service name to be used; if no service name is specified, an instance of # pokie.rest.RestService is automatically created #service_name = 'my-service-name' # optional limit for default listing operations # if list_limit > 0, the specified value will be used as default limit for unbounded listing requests #list_limit = -1 Registering routes RestMixin views can be added to the router using the traditional Flask approach; however, this process often envolves needless creation of similar code. To simplify this process, the pokie.http.route_resource() helper can be used to automate the registration of all endpoints at once: from pokie.http import PokieView from pokie.http.rest import RestMixin from rick.form import RequestRecord , field from rick_db import fieldmapper # DB Record class @fieldmapper ( tablename = 'country' , pk = 'country_id' , schema = 'public' ) class CountryRecord : id = 'country_id' country = 'country' # RequestRecord class class CountryRequest ( RequestRecord ): fields = { 'id' : field ( validators = 'id|numeric' , bind = 'id' ), 'country' : field ( validators = 'required' , bind = 'country' ) } # REST view class class CountryView ( PokieView , RestMixin ): pass ( ... ) # register all routes automatically route_resource ( app , 'country' , CountryView ) The following routes will be registered: Url Method Description /country GET List records /country POST Create record /country/:id GET Get record by id /country/:id PUT Update record /country/:id DELETE Delete record Using RestMixin grid capabilities By leveraging DbGrid capabilities, the RestMixin offers a set of relevant features for advanced scenarios, such as server-side pagination, sorting and search. the following url variables are available: Variable Format Example Description - - /url List all records, see response type below offset /url?offset=5 List records starting at specified zero-based offset limit /url?limit=5 List limit amount of records search /url?search=foo List search results for search expression match field:value|other_field:other_value[...|field...] /url?match=age:22|gender:M List records with exact match on the set of conditions presented sort field:asc,field:desc /url?sort=name:asc,age:desc Sort records by specified conditions Using offset, limit Offset and limit behave like their SQL counterparts - zero-based integer numbers specifying an absolute value. They can be combined to perform pagination: # pagination with 10 records per page /url?offset = 10 & limit = 10 Using search Search is performed in all fields specified in the view class search_fields attribute. The search is performed as case-insensitive %expression% , allowing for matches inside strings. If multiple fields are specified in search_fields , the search is performed with OR concatenation - the result record list is the combination of all individual matches on each field. Some of the internals of the search behaviour can be overridden by providing a custom Service class that extends the pokie.rest.RestServiceMixin mixin and overrides the list() method implementation. Using sort Sort can be performed on multiple fields at once, and sort order can either be 'asc' or 'desc' in case-insensitive form. Default operation and mixing multiple options By default, a naked GET request to the listing endpoint will return all records; However, this may not be desirable when the dataset size is bigger than a few hundred rows. It is possible to cap the default listing to a given number of rows by changing the list_limit class attribute. All or part of the specified options can be combined in a single request, to perform a server-side sorting & filtering procedure. Querying an endpoint with curl, using offset, limit, search and sort on the records: $ curl -X GET -H 'Content-Type: application/json' http://127.0.0.1:5000/my_url?offset = 10 & limit = 10 & search = john & sort = name:desc Response format All RestMixin operations return a variable JSON dataset with the following structure: { \"total\" : 110 , \"rows\" : [ ...lis t o f record objec ts ... ] } Where total is the total amount of rows on the source dataset, ignoring offset and limit constraints, allowing the implementation of server-side pagination.","title":"REST Views"},{"location":"views/rest/#rest-views","text":"Pokie provide several helpers to implement REST endpoints; one of them is the RestMixin mixin. This class extension implements all the basic REST operations for CRUD operations on a given Record/Service. Service can either be the generic pokie.rest.RestService , or a custom service that implements pokie.rest.RestServiceInterface . The RestMixin provides the basic CRUD functionality for a RickDb Record class, effectively allowing automatic creation of CRUD endpoints for database objects, while maintaining a three-tier architectural design. By default, RestMixin will attempt to create a pokie.rest.RestService instance, uniquely named by module and record class. However, if service_name is specified, the associated service will be used instead. Please note that services to be used with the RestMixin class need to extend from pokie.rest.RestServiceMixin . RestMixin example: from pokie.http import PokieView from pokie.http.rest import RestMixin from rick.form import RequestRecord , field from rick_db import fieldmapper # DB Record class @fieldmapper ( tablename = 'country' , pk = 'country_id' , schema = 'public' ) class CountryRecord : id = 'country_id' country = 'country' # RequestRecord class class CountryRequest ( RequestRecord ): fields = { 'id' : field ( validators = 'id|numeric' , bind = 'id' ), 'country' : field ( validators = 'required' , bind = 'country' ) } # REST view class class CountryView ( PokieView , RestMixin ): # RequestRecord class for body operations request_class = CountryRequest # Database Record class record_class = CountryRecord # allowed search fields to be used with the search variable search_fields = [ CountryRecord . country ] # optional custom service name to be used; if no service name is specified, an instance of # pokie.rest.RestService is automatically created #service_name = 'my-service-name' # optional limit for default listing operations # if list_limit > 0, the specified value will be used as default limit for unbounded listing requests #list_limit = -1","title":"REST Views"},{"location":"views/rest/#registering-routes","text":"RestMixin views can be added to the router using the traditional Flask approach; however, this process often envolves needless creation of similar code. To simplify this process, the pokie.http.route_resource() helper can be used to automate the registration of all endpoints at once: from pokie.http import PokieView from pokie.http.rest import RestMixin from rick.form import RequestRecord , field from rick_db import fieldmapper # DB Record class @fieldmapper ( tablename = 'country' , pk = 'country_id' , schema = 'public' ) class CountryRecord : id = 'country_id' country = 'country' # RequestRecord class class CountryRequest ( RequestRecord ): fields = { 'id' : field ( validators = 'id|numeric' , bind = 'id' ), 'country' : field ( validators = 'required' , bind = 'country' ) } # REST view class class CountryView ( PokieView , RestMixin ): pass ( ... ) # register all routes automatically route_resource ( app , 'country' , CountryView ) The following routes will be registered: Url Method Description /country GET List records /country POST Create record /country/:id GET Get record by id /country/:id PUT Update record /country/:id DELETE Delete record","title":"Registering routes"},{"location":"views/rest/#using-restmixin-grid-capabilities","text":"By leveraging DbGrid capabilities, the RestMixin offers a set of relevant features for advanced scenarios, such as server-side pagination, sorting and search. the following url variables are available: Variable Format Example Description - - /url List all records, see response type below offset /url?offset=5 List records starting at specified zero-based offset limit /url?limit=5 List limit amount of records search /url?search=foo List search results for search expression match field:value|other_field:other_value[...|field...] /url?match=age:22|gender:M List records with exact match on the set of conditions presented sort field:asc,field:desc /url?sort=name:asc,age:desc Sort records by specified conditions","title":"Using RestMixin grid capabilities"},{"location":"views/rest/#using-offset-limit","text":"Offset and limit behave like their SQL counterparts - zero-based integer numbers specifying an absolute value. They can be combined to perform pagination: # pagination with 10 records per page /url?offset = 10 & limit = 10","title":"Using offset, limit"},{"location":"views/rest/#using-search","text":"Search is performed in all fields specified in the view class search_fields attribute. The search is performed as case-insensitive %expression% , allowing for matches inside strings. If multiple fields are specified in search_fields , the search is performed with OR concatenation - the result record list is the combination of all individual matches on each field. Some of the internals of the search behaviour can be overridden by providing a custom Service class that extends the pokie.rest.RestServiceMixin mixin and overrides the list() method implementation.","title":"Using search"},{"location":"views/rest/#using-sort","text":"Sort can be performed on multiple fields at once, and sort order can either be 'asc' or 'desc' in case-insensitive form.","title":"Using sort"},{"location":"views/rest/#default-operation-and-mixing-multiple-options","text":"By default, a naked GET request to the listing endpoint will return all records; However, this may not be desirable when the dataset size is bigger than a few hundred rows. It is possible to cap the default listing to a given number of rows by changing the list_limit class attribute. All or part of the specified options can be combined in a single request, to perform a server-side sorting & filtering procedure. Querying an endpoint with curl, using offset, limit, search and sort on the records: $ curl -X GET -H 'Content-Type: application/json' http://127.0.0.1:5000/my_url?offset = 10 & limit = 10 & search = john & sort = name:desc","title":"Default operation and mixing multiple options"},{"location":"views/rest/#response-format","text":"All RestMixin operations return a variable JSON dataset with the following structure: { \"total\" : 110 , \"rows\" : [ ...lis t o f record objec ts ... ] } Where total is the total amount of rows on the source dataset, ignoring offset and limit constraints, allowing the implementation of server-side pagination.","title":"Response format"}]}